<a id="intro"></a>

### Введение
**Данный документ** представляет собой справочное руководство по шаблонизатору BEMHTML. 

В документе описаны: 

* основные особенности BEMHTML, отличающие его от других шаблонизаторов;
* синтаксис описания входных данных BEMJSON и шаблонов BEMHTML;
* порядок обработки входных данных и генерации HTML;
* примеры решения типовых задач средствами BEMHTML.

**Целевая аудитория документа** — веб-разработчики и HTML-верстальщики, использующие
[БЭМ-методологию](http://ru.bem.info/method/). 

Предполагается, что читатель знаком с: 

* HTML;
* JavaScript;
* CSS;
* БЭМ.

**В документе не описаны** настройка среды разработки и процедуры компиляции шаблонов.

<a id="bemhtml"></a>

### Особенности шаблонизатора BEMHTML

<a id="bem_area"></a>

#### Привязка к БЭМ-предметной области
Шаблонизатор BEMHTML входит в связку технологий, обеспечивающих создание веб-интерфейсов в рамках [БЭМ-методологии](http://ru.bem.info/method/).

Входными данными шаблонизатора является описывающее страницу БЭМ-дерево в формате [BEMJSON](#bemjson). Язык шаблонов BEMHTML предлагает специальные конструкции для обработки блоков, элементов и модификаторов.

<a id="decl_templatе"></a>

### Декларативные шаблоны

<a id="imperativ"></a>

#### Императивный подход
Традиционные шаблонизаторы предлагают **императивный подход** к написанию шаблонов: HTML формируется в процессе последовательного чтения и выполнения шаблона. 

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>Результат</th>
</tr>
<tr>
    <td>
        <pre><code>
{
  items: [
    { text: '1' },
    { text: '2' }
  ]
}        </code></pre>
    </td>

    <td>
        <pre><code>
&lt;ul class="menu"&gt;
    [% foreach item in items %]
        &lt;li class="menu__item"&gt;
            [% item.text %]
        &lt;/li&gt;
    [% end %]
&lt;/ul&gt;
        </code></pre>
    </td>
    <td>
        <pre><code>
&lt;ul class="menu"&gt;
    &lt;li class="menu__item">1&lt;/li&gt;
    &lt;li class="menu__item">2&lt;/li&gt;
&lt;/ul&gt;
        </code></pre>
    </td>

</tr>
</table>

В таком шаблоне неизбежна избыточность, вызванная синтаксическими требованиями HTML: //вывести открывающий тег — сгенерировать содержимое — вывести закрывающий тег//. Еще выше избыточность в таблицах, списках и т.п.

<a id="declarativ"></a>
##### Декларативный подход
**Декларативный подход** позволяет формулировать шаблоны как набор простых утверждений вида: //тип входных данных (БЭМ-сущность) — HTML-представление (тег, атрибут, и т.п.)//.

<table>
    <tr>
        <th>Входные данные</th>
        <th>Шаблон</th>
        <th>Результат</th>
    </tr>
    <tr>
        <td>
        <pre><code>
{
    block: 'menu',
    content: [
        { elem: 'item', content: '1' },
        { elem: 'item', content: '2' }
    ]
}
        </code></pre>
        </td>
        <td>
        <pre><code>
block menu {
    tag: 'ul'
    elem item, tag: 'li'
}
        </code></pre>
        </td>
        <td>
        <pre><code>
&lt;;ul class="menu"&gt;;
    &lt;;li class="menu__item"&gt;;1&lt;;/li&gt;;
    &lt;;li class="menu__item"&gt;;2&lt;;/li&gt;;
&lt;;/ul&gt;;
        </code></pre>
        </td>
    </tr>
</table>


Декларативность шаблонов достигается за счет того, что в BEMHTML процедура генерации HTML-элемента стандартизована и выполняется шаблонизатором. Этот же подход к выполнению преобразований данных используется в XSLT и AWK.

<a id="descriptionlanguage"></a>

#### Язык описания шаблонов — JavaScript
BEMHTML представляет собой специализированный язык (DSL), **расширяющий** JavaScript.

Точнее, BEMHTML является надмножеством языка шаблонов [XJST](https://github.com/veged/xjst/), который, в свою очередь, является надмножеством JavaScript.

Синтаксис BEMHTML предоставляет лаконичный способ записи соответствия БЭМ-сущностей и генерации HTML-элементов и атрибутов.
Помимо этого, в шаблонах могут использоваться **любые** JavaScript-конструкции.

<a id="execution_language"></a>

#### Язык исполнения шаблонов — JavaScript
Перед выполнением BEMHTML компилируется в оптимизированный JavaScript, который принимает BEMJSON и возвращает HTML. 

Такой шаблон может выполняться как на стороне сервера, так и на стороне клиента.

<a id="restrictions"></a>

#### Ограничения на уровне соглашений
Разработчики BEMHTML стремились сделать его максимально гибким инструментом, поэтому в BEMHTML не предусмотрено технологических ограничений на операции, выполняемые в шаблонах. Фактически, в BEMHTML-коде возможно всё, что возможно в JavaScript.

Все ограничения, обеспечивающие корректность и эффективность выполнения задач шаблонизатора, реализуются на уровне соглашений по написанию шаблонов. Такие соглашения приводятся в данном документе в качестве рекомендаций. Разработчик имеет техническую возможность не следовать соглашениям, но в этом случае следует взвесить преимущества и недостатки своего решения.

<a id="basic"></a>

### Основные понятия

<a id="inputdata"></a>

#### Входные данные: BEMJSON
Поскольку BEMHTML основан на JavaScript, в качестве формата представления БЭМ-дерева выбран JSON с набором дополнительных соглашений о представлении БЭМ-сущностей — BEMJSON.

Задача шаблонизатора BEMHTML — преобразовать входное БЭМ-дерево в выходной HTML-документ. В целях сохранения гибкости и поддерживаемости, на уровне шаблонизатора не следует производить сложных преобразований входных данных. Шаблоны должны быть максимально простыми утверждениями, сопоставляющими каждому типу БЭМ-сущности нужное HTML-оформление.

Поэтому структура входного БЭМ-дерева должна быть ориентирована на **представление** (view), когда при генерации HTML-дерева не потребуется изменений в наборе и порядке блоков и элементов. Приведение БЭМ-дерева к такому развернутому виду должно производиться на уровне бэкенда, предшествующего шаблонизатору. Иллюстрацией view-ориентированного формата данных может служить пример френдленты, разобранный в разделе ((#privedenievxodnyxdannyxkformatuorientirovannomunapredstavlenie Приведение данных к формату, ориентированному на представление)).

В то же время детали организации HTML-страницы, которые являются зоной ответственности верстальщика, должны определяться только на уровне шаблонизатора. Пример такого решения приведен в разделе ((#additionbem Добавление БЭМ-сущностей для задач верстки)).

**См. также**:

  * [Синтаксис BEMJSON](#bemjson)

<a id="templatebemjson"></a>

#### Шаблон
Единицей программы на BEMHTML является **шаблон**. Шаблон BEMHTML связывает входную БЭМ-сущность (заданную именем сущности, элемента, именем и значением модификатора) и соответствующий этой сущности HTML-элемент.

Шаблон состоит из:

* **предиката** — набора условий, при выполнении которых применяется шаблон. Типичный предикат описывает свойства входной БЭМ-сущности;
* и **тела** — инструкций по генерации выходного HTML.

**См. также**:

* [Синтаксис BEMHTML](#bemhtml).

<a id="moda"></a>

#### Мода
В процессе работы шаблонизатор последовательно обходит узлы входного БЭМ-дерева. Для каждого узла — БЭМ-сущности — выполняется цикл генерации выходного HTML-элемента. Для вложенных сущностей цикл генерации HTML-элементов выполняется рекурсивно. Таким образом, выходное HTML-дерево формируется поэлементно в процессе обхода входного БЭМ-дерева.

Цикл генерации каждого элемента последовательно проходит ряд фаз, называемых **модами**. Каждая мода отвечает за определенный фрагмент генерируемого HTML-элемента — тег, атрибуты, класс и т.п. В каждой моде вызывается процедура выбора и выполнения подходящего шаблона. 

Моды позволяют разделить выходной элемент на фрагменты, каждый из которых может быть описан простым типом данных: тег и класс — строкой, атрибуты — словарем, необходимость в БЭМ-классах — логическим значением и т.п. Благодаря этому возможно написание декларативных шаблонов, в предикате которых указана мода, а в теле содержатся данные соответствующего этой моде простого типа. В этом случае полное представление HTML-элемента может быть задано несколькими шаблонами.

Особый статус имеет **[мода default](#default)**, которая отвечает за генерацию целого HTML-элемента. В рамках этой моды задан набор и порядок прохождения остальных мод, соответствующих фрагментам HTML-элемента, а также определена процедура сборки финального представления HTML-элемента из фрагментов, сгенерированных в остальных модах. Написание шаблона, который переопределяет поведение в данной моде, позволяет полностью контролировать генерацию элемента из BEMHTML, не пользуясь стандартными модами, позволяющими генерировать выходной элемент по частям.

**См. также**:

* [Стандартные моды](#standardemoda).

<a id="context"></a>

#### Контекст
В процессе обхода входного BEMJSON-дерева шаблонизатор строит **контекст** — структуру данных, с которой работают шаблоны. Контекст соответствует текущему элементу (узлу) входного БЭМ-дерева и включает:

* нормализованные сведения о текущей БЭМ-сущности;
* фрагмент входных данных без модификаций (текущий элемент BEMJSON-дерева и его потомки);
* строковый буфер, в который записывается HTML-результат;
* служебные поля, содержание сведения о текущем состоянии (мода, позиция во входном БЭМ-дереве и т.п.);
* вспомогательные функции.

БЭМ-сущность, описываемая текущим контекстом, называется **контекстной сущностью**.

**См. также**:

* [Поля контекста](#context_field).
* [Достраивание БЭМ-сущностей по контексту](#extensionbem).

<a id="bemjson"></a>

### Синтаксис BEMJSON

<a id="datatype"></a>

#### Типы данных
Типы данных в BEMJSON аналогичны соответствующим типам в JavaScript.

* Строки и числа:

 * **Строка** `` 'a' `` `"a"`;
 * **Число** `1` `0.1`;    
    Структура данных, состоящая из строки или числа, является валидным BEMJSON.

* **Объект** (ассоциативный массив) '{ключ: значение}' и остальные типы, кроме массива.
* **Массив** — список, может содержать элементы различных типов (строки, числа, объекты, массивы) `[ "a", 1, {ключ: значение}, [ "b", 2, ... ] ]`.

<a id="fields_bemjson"></a>

#### Специальные поля BEMJSON
Для представления данных предметной области БЭМ и HTML в BEMJSON используются объекты, в которых зарезервированы специальные имена полей. 

<a id="notionbem"></a>

#####Представление БЭМ-сущностей
БЭМ-сущности представляются в BEMJSON в виде объектов, в которых могут присутствовать следующие поля:

<table>
<tr>
    <th>Поле</th>
    <th>Значение</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>block</code></td>
    <td>Имя блока</td>
    <td>Строка</td>
    <td><code>{ block: 'b-menu' }</code></td>    
</tr>

<tr>
    <td><code>elem</code></td>
    <td>Имя элемента</td>
    <td>Строка</td>
    <td><code>{ elem: 'item' }</code></td>    
</tr>

<tr>
    <td><code>mods</code></td>
    <td>Модификаторы блока</td>
    <td>Объект, содержащий имена и значения модификаторов в качестве пар ключ—значение:<code>{имя_модификатора: 'значение_модификатора'}</code></td>
    <td>
        <pre><code>
{
  block: 'b-link', 
  mods: { pseudo: 'yes', color: 'green' }
}
        </code></pre>
    </td>    
</tr>

<tr>
    <td><code>elemMods</code></td>
    <td>Модификаторы элемента</td>
    <td>Объект, содержащий имена и значения модификаторов элемента в качестве пар ключ—значение:<code>{имя_модификатора: 'значение_модификатора'}</code></td>
    <td>
        <pre><code>
{
  elem: 'item', 
  elemMods: { selected: 'yes' }
}
        </pre></code>
    </td>    
</tr>

<tr>
    <td><code>mix</code></td>
    <td>Подмешанные блоки/элементы</td>
    <td>Массив, содержащий объекты, описывающие подмешанные блоки и элементы. В качестве значения может выступать объект, который трактуется как массив, состоящий из одного элемента.</td>
    <td>
        <pre><code>
{
  block: 'b-link',
  mix: [ { block: 'b-serp-item', elem: 'link' } ]
}
        </code></pre>
    </td>    
</tr>
</table>

**См. также**:

* [Достраивание БЭМ-сущностей по контексту](#extensionbem)

<a id="notionhtml"></a>

##### Представление HTML
BEMJSON предоставляет возможность задавать некоторые аспекты выходного HTML непосредственно во входных данных. Этой возможностью не следует злоупотреблять, т.к. BEMJSON представляет собой уровень данных, а непосредственное оформление HTML должно выполняться на уровне шаблонизатора (BEMHTML). Однако возможны ситуации, где оправданно описание HTML-представления на уровне BEMJSON. В этом случае автор шаблонов BEMHTML должен понимать, каким образом параметры HTML, заданные входными данными, взаимодействуют с HTML-представлением, определенным на уровне шаблонов.

В BEMJSON предусмотрены следующие поля для непосредственного управления HTML-представлением:

<table>
<tr>
    <th>Поле</th>
    <th>Значение</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>tag</code></td>
    <td>HTML-тег для данной сущности</td>
    <td><code>String</code></td>
    <td>
        <pre><code>
{
  block: 'b-my-block',
  tag: 'img'
}
        </code></pre>
    </td>
    
</tr>
<tr>
    <td><code>attrs</code></td>
    <td>HTML-атрибуты для данной сущности</td>
    <td><code>Object</code></td>
    <td>
        <pre><code>
{
  block: 'b-my-block',
  tag: 'img',
  attrs: { src: '//yandex.ru/favicon.ico', alt: '' }
}
        </code></pre>
    </td>
    
</tr>
<tr>
    <td><code>cls</code></td>
    <td>Строка, добавляемая к HTML-атрибуту <code>class</code> (помимо автоматически генерируемых классов)</td>
    <td><code>String</code></td>
    <td>
        <pre><code>
             {
  block: 'b-my-block',
  cls: 'some-blah-class'
}
        </code></pre>
    </td>
    
</tr>
<tr>
    <td><code>bem</code></td>
    <td>Флаг — отменить генерацию БЭМ-классов в HTML-атрибуте <code>class</code> для данной сущности </td>
    <td><code>Boolean</code></td>
    <td>
        <pre><code>
{
block: 'b-page',
tag: 'html',
bem: false
}
        </code></pre>
    </td>    
</tr>
<tr>
    <td><code>js</code></td>
    <td>Либо флаг о наличии клиентского JavaScript у данной сущности, либо параметры JavaScript</td>
    <td><code>Boolean</code></td>
    
    <td>
        <pre><code>
{
  block: 'b-form-input',
  mods: { autocomplete: 'yes' },
  js: {
    dataprovider: { url: 'http://suggest.yandex.ru/...' }
  }
}
        </code></pre>
    </td>    
</tr>
</table>

Обратите внимание, что имена и смысл полей BEMJSON, управляющих HTML-представлением, совпадают с именами и смыслом соответствующих [стандартных мод](#standardmoda) BEMHTML (тег, атрибуты, класс и т.п.). В случае, если какие-то из аспектов выходного HTML заданы **и во входных данных, и в BEMHTML-шаблонах**, то более высокий приоритет имеют значения, заданные в BEMHTML-шаблонах.

При генерации HTML будет выполнено одно из двух действий:

* **Объединение** значений HTML-параметров, заданных в BEMJSON, cо значениями параметров, заданных в BEMHTML-шаблоне. Объединение значений производится только для тех параметров, для которых оно имеет очевидный смысл: `attrs`, `js`, `mix`.
* **Замещение** значений HTML-параметров, заданных в BEMJSON, значениями, заданными в **BEMHTML-шаблоне**. Выполняется для всех прочих значений: `tag`, `cls`, `bem`, `content`. 

***
**NB** Приоритет BEMHTML-шаблонов позволяет **автору шаблонов** принимать решение, какие HTML-параметры будут приоритетнее в каждом конкретном случае — заданные в BEMHTML или в BEMJSON. Значения HTML-параметров, заданных в BEMJSON, доступны в шаблонах при обращении к фрагменту входного BEMJSON-дерева в контексте (поле `this.ctx`).
***

<a id="nesting"></a>

##### Вложенность: content
Для представления вложенных БЭМ-сущностей (БЭМ-дерева) в BEMJSON зарезервировано поле `content`. В качестве значения данного поля может выступать произвольный BEMJSON: 

* Примитивный тип (строка, число). Значение используется в качестве содержимого (текста) HTML-элемента, соответствующего контекстной сущности.
* Объект, описывающий БЭМ-дерево. Значение используется для генерации HTML-элементов, вложенных в HTML-элемент, соответствующий контекстной сущности.

Уровень вложенности дерева БЭМ-сущностей, построенного с помощью поля `content`, не ограничен.

**См. также**:

* [Мода content](#content)

<a id="custom_fields"></a>

##### Произвольные поля
Помимо специальных полей, описывающих БЭМ-сущность и ее HTML-представление, в том же объекте могут присутствовать любые поля с произвольными данными, которые будут доступны для использования в BEMHTML-шаблонах. 

Примером произвольного поля может служить поле `url` в блоке ссылки:

<pre><code>
{
block: 'b-link',
url: '//yandex.ru'
}
</code></pre>

Пример использования данных из поля `url` см. в разделе: [Выбор шаблона по условию](#select_template).

<a id="customjs"></a>

#### Произвольный JavaScript в BEMJSON
BEMJSON является менее ограниченным форматом, чем JSON. Произвольные JavaScript-выражения будут валидным BEMJSON. 

Специфика BEMJSON как формата данных заключается в соблюдении описанных в предшествующих разделах соглашений по именованию полей в объектах (для представления БЭМ-сущностей и HTML-представления) и правил вложения объектов.

<a id="bemhtml"></a>
### Синтаксис BEMHTML
В данном разделе описаны все синтаксические конструкции языка BEMHTML. 

<a id="template"></a>

#### Шаблон
Шаблон состоит из двух выражений — **предиката** и **тела**, разделенных двоеточием. Допускается произвольное количество либо отсутствие пробелов до и после двоеточия:

`предикат: тело`

Каждый **предикат** представляет собой список из одного или более **подпредикатов** (условий), разделенных запятыми. 

`подпредикат1, подпредикат2, подпредикат3: тело`

Запятая соответствует логическому оператору "И". Предикат шаблона истинен тогда и только тогда, когда истинны все подпредикаты. Порядок записи подпредикатов не имеет значения, !!порядок проверки подпредикатов не гарантируется!!.

Логически программа на BEMHTML представляет собой одноранговый (плоский) **список шаблонов**. Однако если несколько шаблонов имеют **общие подпредикаты**, они могут быть записаны в виде вложенной структуры для минимизации повторов в коде.

Для обозначения вложенности используются фигурные скобки. Фигурные скобки ставятся после общей части предикатов, в них заключается блок кода, содержащий различающиеся части предикатов и соответствующие им тела шаблонов. Уровень вложенности подпредикатов не ограничен.

<pre><code>
подредикат1 {
  подпредикат2: тело1
  подпредикат3: тело2
}
</code></pre>


Данная запись эквивалентна следующей:

<pre><code>
подпредикат 1, подпредикат 2: тело1    
подпредикат 1, подпредикат 3: тело2
</code></pre>

----
**NB** Если для данного контекста определено более одного шаблона, то выполняется **последний** в порядке перечисления в BEMHTML-файле.
Более специфические шаблоны должны быть ниже в тексте, чем более общие.
***

**См. также**:

* [Проверка подпредикатов в определенном порядке](#check_predicate)
  
<a id="podpredicate"></a>

#### Подпредикаты
Предикат шаблона представляет собой набор условий, описывающих момент применения шаблона. Подпредикат шаблона соответствует элементарному условию.

В BEMHTML предусмотрены следующие типы условий:

* Совпадение с входным БЭМ-деревом.
* Мода.
* Произвольное условие


##### Совпадение с входным БЭМ-деревом
Условия совпадения с входным БЭМ-деревом позволяют описывать применимость шаблона в терминах БЭМ-сущностей: имен блоков и элементов, имен и значений модификаторов.

Для этого в предикатах используются следующие ключевые слова:
<table>
<tr>
    <th>Ключевое слово</th>
    <th>Аргументы</th>
    <th>Тип значения</th>
    <th>Пример</th>
</tr>
<tr>
    <td><code>block</code></td>
    <td>имя блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code> или произвольное js-выражение</td>
    <td><code>block b-menu, block 'b-menu', block 'b' + '-menu'</code></td>
</tr>
<tr>
    <td><code>elem</code></td>
    <td>имя элемента</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+</code> или произвольное js-выражение</td>
    <td><code>block b-menu, elem item</code></td>
</tr>
<tr>
    <td><code>mod</code></td>
    <td>имя и значение модификатора блока</td>
    <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
    <td><code>block b-head-logo, mod size big</code></td>
</tr>
<tr>
   <td><code>elemMod</code></td>
   <td>имя и значение модификатора элемента</td>
   <td>идентификатор <code>[a-zA-Z0-9-]+ </code>или произвольное js-выражение</td>
   <td><code>block b-head-logo, elem text, elemMod size big</code></td>
</tr>
</table>


Идентификаторы блоков, элементов, модификаторов и их значений пишутся без кавычек. Парсер BEMHTML рассматривает в качестве идентификатора любую строку, состоящую из латинских символов и дефиса. Вместо идентификатора может быть указано любое JS-выражение, которое будет приведено к строке.

----
**NB**: Важно не путать в предикатах модификаторы блока и модификаторы элемента. 

 * `block input, mod theme black, elem hint` задает элемент `hint`, вложенный в блок `input` с **модификатором блока** `theme` в значении `black`.
 * `block input, elem hint, elemMod visibility visible` задает элемент `hint` с **модификатором элемента** `visibility` в значении `visible` вложенный в блок `input`.
 * `block input, mod theme black, elem hint, elemMod visibility visible` задает элемент `hint` с **модификатором элемента** `visibility` в значении `visible` вложенный в блок `input` с **модификатором блока** `theme` в значении `black`.

Для модификаторов блоков и элементов используются разные ключевые слова, чтобы дать возможность комбинировать в предикатах условия, одновременно включающие упоминания модификаторов блоков и элементов.
***
<a id="moda2"></a>
##### Мода
В качестве подпредиката может выступать название одной из [стандартных мод](#standardmoda). Это означает, что данный предикат будет истинным в тот момент обработки, когда выставлена соответствующая мода.

Для проверки стандартных мод используются ключевые слова:

* `default`
* `tag`
* `bem`
* `mix`
* `cls`
* `js`
* `jsAttr`
* `attrs`
* `content`

Кроме того, любой подпредикат, состоящий только из идентификатора (`[a-zA-Z0-9-]+`), интерпретируется как название нестандартной моды. Например, подпредикат `my-mode` эквивалентен подпредикату `` this._mode === 'my-mode' ``.

<a id="random_condition"></a>
##### Произвольное условие
Произвольные условия учитывают совпадения с данными, не попадающими под предметную область БЭМ. В качестве произвольного условия может выступать любое JavaScript-выражение, которое будет приведено к логическому значению.

***
**NB** Произвольные условия предпочтительно записывать в **канонической форме XJST**:
 
`предикатное выражение === значение`

Где
 
* `предикатное выражение` — произвольное JavaScript-выражение, приводимое к логическому значению;
* `значение` — произвольное JavaScript-выражение. 
При этом количество **различных** предикатных выражений в подпредикатах шаблонов должно быть минимизировано. Соблюдение этих условий позволит компилятору XJST производить оптимизации над произвольными условиями шаблонов наряду с оптимизацией стандартизованных условий (БЭМ-сущности и моды).
***

<a id="body"></a>

#### Тело
Тело шаблона представляет собой выражение, результат вычисления которого используется для генерации выходного HTML.
В качестве тела шаблона может выступать: 

* Отдельное JavaScript-выражение:

  `предикат: JS-выражение`
* Блок JavaScript-кода, заключенный в фигурные скобки:

  `предикат:   { JS-блок }`

***

**NB** Парсер BEMHTML всегда интерпретирует фигурную скобку в начале тела шаблона как обозначение блока JavaScript-кода, поэтому если необходимо в качестве JavaScript-выражения в теле шаблона использовать хэш (объект), его следует заключать в круглые скобки:

`предикат: ({name: value})`

***

В рамках тела шаблона можно выполнить следующие действия: 

* Вычислить и вернуть значение. 
  Если в текущей моде ожидается значение определенного типа, значение, возращаемое при вычислении тела шаблона, будет приведено к этому типу и использовано. Если шаблон не возвращает никакого значения, будет использовано значение `undefined`.
* Вывести данные непосредственно в HTML-результат. 
  Для этого в теле шаблона следует выполнить запись в буфер HTML-результата (`this._buf.push(…)`).
* Производить произвольные операции.

<a id="xjst"></a>

#### Конструкции XJST
Так как язык BEMHTML является расширением языка XJST, в BEMHTML-шаблонах возможно использовать синтаксические конструкции XJST для модификации контекста и явного вызова процедуры выбора и выполнения шаблонов в измененном контексте.

<a id="local"></a>

##### local
Конструкция `local` (язык XJST) используется для временного изменения контекста и переменных, также для последующих операций с ними. По синтаксису блок кода `local` подобен блокам `while` и `for` в JavaScript.

Возможны следующие варианты записи блока `local`:

* Тело в виде js-выражения:

    `local(expressions) code`
* Тело в виде js-блока:

    `local(expressions) { code }`

Здесь
 
* `expressions` — это список выражений, представляющих собой операции присваивания значений переменным;
* `code` — JavaScript-код, который выполняется в контексте, где значения переменных соответствуют присвоенным в блоке `expressions`.

По выходу из блока local все переменные, значения которых изменялись в блоке `expressions`, приобретают те значения, которые в них хранились на момент входа в блок. Возвращение исходных значений производится в порядке, обратном порядку присваивания переменных в блоке `expressions`.

---
**NB** Если в блоке `expressions` было присвоено значение переменной (полю объекта), которая не была определена на момент входа в блок `local`, по выходу из блока `local` эта переменная (поле) будет существовать и получит значение `undefined`.

---

**См. также**:

* Подробнее о конструкции local [в документации XJST](http://github.com/veged/xjst/blob/master/README.md#local).

<a id="apply"></a>

##### apply
Конструкция `apply` предназначена для явного вызова процедуры выбора и выполнения шаблона, предикат которого истинен в данном контексте. Конструкция позволяет вызывать шаблоны в модифицированном контексте.

Синтаксис:

`apply(expressions)`

Где `expressions` — это список выражений, модифицирующих контекст.  Список может быть пуст. 

Каждое выражение в списке `expressions` может представлять собой:

* Операцию присваивания значений переменным. Аналогично блоку expressions в [конструкции local](#local).
* !!(зел)Новое в bem-bl 0.3!! Строку или приводимое к ней выражение. Означает «выставить указанную строку в качестве моды».

    Например, выражение `apply('content')` эквивалентно выражению`apply(this._mode = 'content')`.

При вычислении выражения `apply` выполняются следующие шаги:

1. Выполнение выражений (присваиваний) в блоке `expressions`.
2. Вызов процедуры выбора и выполнения шаблона в контексте, полученном в результате шага 1.
3. Восстановление значений переменных.

Конструкция `apply(expressions)` представляет собой сокращенную запись выражения `local(expressions) { apply() }`.

<a id="applynext"></a>

##### applyNext
!!(зел)Новое в bem-bl 0.3!!

Конструкция `applyNext` позволяет заново запустить процедуру применения шаблонов к текущему контексту непосредственно в теле шаблона. Результат вычисляется так, как если бы шаблона, в котором используется данная конструкция, не было. Конструкция возвращает значение, вычисленное в результате применения шаблонов к текущему контексту.

Синтаксис:

`applyNext(expressions)`

Где `expressions` — список выражений, модифицирующих контекст (операций присваивания значений переменным или строка, означающая присвоение моды). Список может быть пуст. Аналогично блоку `expressions` в [конструкции apply](#apply).

При вызове `applyNext` выполняются следующие шаги:

  1. Создание в контексте флага, позволяющего избежать бесконечной рекурсии при вызове шаблонов. В качестве флага используется случайное число.
  2. Добавление в предикат шаблона проверки на наличие флага.
  3. Выполнение блока `expressions` (модификация текущего контекста).
  4. Вызов процедуры выбора и выполнения шаблона `apply()`.
  5. Возвращение значения, полученного в результате выполнения шаблона.

Например, шаблон 

<pre><code>
block b1:   {  
    statements   
    applyNext()   
}
</code></pre>

эквивалентен следующему шаблону:

<pre><code>
var _randomflag = ~~(Math.random() * 1e9)   
block b1, !this.ctx._randomflag: {   
    statements   
    local(this.ctx._randomflag = true) apply()   
}
</code></pre>

Где `statements` — произвольные JS-выражения, допустимые в теле шаблона.

**См. также**:

* [Наследование](#inheritage).
* [Добавление БЭМ-сущностей для задач верстки](#additionbem).


<a id="applyctx"></a>

##### applyCtx

Конструкция `applyCtx` предназначена для модификации фрагмента входного БЭМ-дерева `this.ctx` и последующего вызова процедуры применения шаблонов `apply()` к контексту с модифицированным БЭМ-деревом. 

Синтаксис:

`applyCtx(newctx)`

Где в качестве `newctx` может выступать:

* Объект (хэш), который будет использован в качестве входного фрагмента БЭМ-дерева. Может содержать ссылки на исходный `this.ctx`.
* Операция присваивания переменной.

В ходе вычисления выражения `applyCtx` выполняются следующие шаги:

  1. Создание в контексте флага, позволяющего избежать бесконечной рекурсии при вызове шаблонов. В качестве флага используется случайное число.
  2. Добавление в предикат шаблона проверки на наличие флага.
  3. Выставление [пустой моды](#pustajamodaquotquot) в качестве текущей.
  4. Вызов процедуры выбора и выполнения шаблона `apply()`.
  5. Возвращение значения, полученного в результате выполнения шаблона.

Выражение `applyCtx(newctx)` представляет собой сокращенную запись для выражения `applyNext(this.ctx = {newctx}, '')`.

**См. также**:

  * [Оборачивание блока в другой блок](#wrappingunit)
  * [Добавление БЭМ-сущностей для задач верстки](#additionbem)

<a id="standardmoda"></a>

### Стандартные моды
В ядре BEMHTML определен набор стандартных мод, которые задают порядок обхода входного БЭМ-дерева (BEMJSON) и генерации выходного HTML, используемый BEMHTML по умолчанию.

По функциональности моды разделяются на два класса: 

  * **«Пустая» мода** определяет алгоритм обхода узлов входного BEMHTML и вызова остальных мод;
  * Все остальные моды определяют порядок генерации выходного HTML. В каждой из таких мод формируется тот или иной фрагмент выходного HTML-дерева. 

Для генерации HTML в каждой моде вызывается процедура выбора и выполнения подходящего шаблона (предикат которого истинен в данном контексте). Результат вычисления тела выбранного шаблона подставляется в тот фрагмент HTML-дерева (HTML-элемента), за генерацию которого отвечает данная мода.

Данная логика работы накладывает следующие ограничения на шаблоны:

  * Если шаблон выводит какие-то данные в HTML, в его предикате должна быть указана мода.
  * В предикате шаблона может быть указано не более одной моды.
  * В результате вычисления тела шаблона должен возвращаться тот тип объекта, который ожидается в рамках данной моды.

В последующих разделах моды перечислены в порядке их вызова при обработке элемента входного BEMJSON.

<a id="empty_moda"></a>

#### «Пустая» мода (`""`)    
!!(зел)Тип значения тела шаблона: `не используется`!!

Пустая (не определенная) мода соответствует моменту, когда значение поля контекста `this._mode` равно пустой стоке (`""`). Это значение выставляется: 

  * перед началом обработки входного дерева;
  * в момент рекурсивного вызова процедуры обхода дерева в моде `default`.

Действие, выполняемое в рамках пустой моды, зависит от типа контекстного (текущего) элемента входного BEMJSON-дерева.

<table>
<tr>
    <th>Тип элемента</th>
    <th>Действие</th>
</tr>
<tr>
    <td><b>БЭМ-сущность</b>(блок или элемент)</td>
    <td>Выставление значений в служебных полях контекста (<code>block elem mods elemMods ctx position</code>) и вызов шаблонов по моде <code>default</code>.</td>
</tr>

<tr>
    <th>строка/число</th>
    <td>Вывод значения, приведенного к строке, в буфер HTML-результата.</td>
</tr>
<tr>
    <th>Boolean, undefined, null</th>
    <td>Вывод пустой строки в буфер HTML-результата.</td>
</tr>
<tr>
    <th>массив</th>
    <td>Итерация по массиву с рекурсивным вызовом шаблонов по пустой моде.</td>
</tr>
</table>


Определение шаблона по пустой моде (подпредикат `this._mode === ""`) имеет смысл только в том случае, если необходимо переопределить принцип обхода входного дерева. 
 
Вызов шаблонов по пустой моде (конструкция `apply('')` в теле шаблона) необходим, если требуется отклониться от однозначного соответствия «входная БЭМ-сущность — выходной HTML-элемент» и сгенерировать более одного элемента на одну входную сущность. В частности, такой вызов осуществляется автоматически при использовании [конструкции  applyCtx](#applyctx).

**См. также**:

  * [Оборачивание блока в другой блок](#wrappingunit)

<a id="default"></a>

#### default
!!(зел)Тип значения тела шаблона: `не используется`!!

В рамках моды `default` полностью формируется выходной HTML-элемент, соответствующий входной БЭМ-сущности.

В ходе выполнения моды default происходит:
 
  * вызов всех остальных стандартных мод, отвечающих за формирование отдельных аспектов HTML-элемента;
  * объединение результатов выполнения всех вызываемых мод в результирующую HTML-строку;
  * рекурсивный вызов шаблонов на результат выполнения моды `content`.

На рисунке ниже схематически отражено, в каких модах генерируются различные фрагменты выходного HTML-элемента.
 
![mode-default](/Users/salivan/Yandex.Disk.localized/Документы/photo/reference_mode-default.png)

Схема отражает вариант обработки элемента, имеющего пару открывающий—закрывающий тег и вложенное содержимое. Обработка коротких (самозакрытых) элементов аналогична и отличается только отсутствием закрывающего тега и рекурсии. Следует ли обрабатывать данный элемент как короткий, определяет вспомогательная функция контекста `this._.isShortTag` на основании имени элемента (тега).

Определение шаблона по моде `default` (подпредикат `default`) необходимо в тех случаях, когда нужно переопределить процедуру генерации выходного HTML-элемента, например, добавить DOCTYPE к тегу HTML:

<pre><code>
block b-page {    
  default: {    
    this._buf.push('<!DOCTYPE html>');    
    applyNext();   
  }    
  tag: 'html'    
}
</code></pre>

<a id="tag"></a>

#### tag
!!(зел)Тип значения тела шаблона: `String`!!        
!!(зел)Значение по умолчанию: `` 'div' ``!!

Мода `tag` задает имя выходного HTML-элемента (тег). По умолчанию имя элемента равно `div`. Фрагменты HTML, за генерацию которых отвечает мода `tag`, выделены на рисунке:

![mode-default](/Users/salivan/Yandex.Disk.localized/Документы/photo/reference_mode-default.png)

***
**NB** Если в качестве значения `tag` указать пустую строку, для данной сущности будет пропущен этап генерации HTML-элемента (тега и всех атрибутов), но содержимое элемента (`content`) будет обработано обычным образом.
***

Определение шаблона по моде `tag` (подпредикат `tag`) необходимо, если:

  * для данной сущности следует сгенерировать HTML-элемент с именем, отличным от `div`;
  * отказаться от генерации HTML-элемента для данной сущности, но обработать вложенные сущности.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>
        {
  block: 'b1', 
  content: 'text'
}</code></pre>
    </td>

    <td><code>block b1, tag: 'span'</td>
    <td>&lt;span class="b1"&gt;text&lt;/span&gt;</td>

</tr>

<tr>
    <td>
        <pre><code>
        {
  block: 'b1',
  content: {
    block: 'b2'
    }
}
        </code></pre>
    </td>

    <td><code>b1, tag: ''</code></td>
    <td>&lt;div class="b2"&gt;&lt;/div&gt;</td>

</tr>
</table>

<a id="js"></a>

#### js
!!(зел)Тип значения тела шаблона: `Boolean|Object`!!    
!!(зел)Значение по умолчанию: `false`!!

Мода `js` указывает, есть ли у обрабатываемого блока клиентский JavaScript. В случае наличия JavaScript в моде `js` могут быть переданы параметры клиентского JavaScript (записываются в атрибут HTML-элемента, имя которого определяется [модой `jsAttr`](#jsattr). 

Мода `js` допускает два типа значения тела шаблона: 

  * `Boolean` — Флаг, указывающий, имеет ли данный блок клиентский JavaScript.
  * `Object` — Хэш, содержащий параметры JavaScript (подразумевается, что данный блок имеет клиентский JavaScript).
  
Фрагменты HTML, за генерацию которых отвечает мода `js`, выделены на рисунке:
file:mode-js.png

Определение шаблона по моде `js` (подпредикат `js`) имеет смысл только в том случае, если у блока имеется клиентский JavaScript.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td><code>{block: 'b1'}</code></td>
    <td><code>block b1, js: true</code></td>
    <td>&lt;div class="b1 i-bem" onclick="return { 'b1': {} }"&gt;&lt;/div&gt;</td>

</tr>

<tr>
    <td><code>{block: 'b1'}</code></td>
    <td><code>block b1, js: {param: 'value'}</code></td>
    <td>&lt;div class="b1 i-bem" onclick="return { 'b1': { 'param': 'value' } }"&gt;&lt;/div&gt;</td>
</tr>
</table>

**См. также**:

  * [JS-реализация блока i-bem](http://bem.github.com/bem-bl/sets/common-desktop/i-bem/i-bem.ru.html)

<a id="bem"></a>

#### bem
!!(зел)Тип значения тела шаблона: `Boolean`!!    
!!(зел)Значение по умолчанию: `true`!!

Мода `bem` указывает, нужно ли при формировании HTML-атрибута `class` включать автоматически сгенерированные имена классов, описывающие данную БЭМ-сущность. По умолчанию генерация БЭМ-классов выполняется. Фрагмент HTML, за генерацию которого отвечает мода `bem`, выделен на рисунке:
file:mode-bem.png

Определение шаблона по моде `bem` (подпредикат `bem`) имеет смысл только в том случае, если для данной сущности **не нужно** генерировать HTML-классы, относящиеся к БЭМ-предметной области. Это может быть необходимо для соблюдения синтаксических требований HTML. Например, теги `html`, `meta`, `link`, `script`, `style` не могут иметь атрибута `class`.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>
{
  block: 'b-page'
}
       
        </code></pre>
    </td>
    
    <td>
        <pre><code>
block b-page {
  tag: 'html'
  bem: false
  }
        </code></pre>
    </td>
    <td>&lt;html&gt;&lt;/html&gt;</td>
</tr>
</table>


<a id="cls"></a>
#### cls

!!(зел)Тип значения тела шаблона: `String`!!    
!!(зел)Значение по умолчанию: `''`!!

Мода `cls` позволяет определить произвольную строку, добавляемую в значение атрибута `class` помимо автоматически генерируемых значений. Фрагмент HTML, за генерацию которого отвечает мода `cls`, выделен на рисунке:
file:mode-cls.png

Определение шаблона по моде `cls` (подпредикат `cls`) имеет смысл в том случае, если для данного элемента необходимы специфические HTML-классы, не относящиеся к предметной области БЭМ. 

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>
{
  block: 'b1'
}       
        </code></pre>
    </td>
    
    <td>
        <code>block b1, cls: 'custom'</code>
    </td>
    <td>&lt;div class="b1 custom"&gt;&lt;/div&gt;</td>
</tr>
</table>


<a id="mix"></a>

#### mix
!!(зел)Тип значения тела шаблона: `Array|Object`!!

!!(зел)Значение по умолчанию: `[]`!!

Мода `mix` задает список БЭМ-сущностей, которые необходимо **примешать** к данной сущности. Сущность, в рамках которой выполняется примешивание, называется **базовой**, а добавляемая сущность — **примешиваемой**. Имеет смысл примешивание блоков и элементов.

Технически примешивание сводится к следующим операциям: 
  * БЭМ-классы примешиваемой сущности добавляются в значение атрибута `class` текущего элемента наряду с классами базовой сущности. 
  * Если примешиваемая сущность имеет JavaScript-параметры, они добавляются в значение атрибута, заданного модой `jsAttr`. JavaScript-параметры передаются в виде хэша, ключом является имя примешиваемой сущности. 

Все прочие составляющие HTML-элемента (тег, атрибуты и под.) генерируются на основании шаблонов для базовой сущности. 

Значением тела шаблона для данной моды может быть:

  * **Массив**, в котором содержится список объектов (хэшей), каждый из которых описывает БЭМ-сущности, которые необходимо подмешать.
  * **Объект**, описывающий примешиваемую БЭМ-сущность. Интерпретируется как массив, состоящий из одного элемента. 

Фрагмент HTML, за генерацию которого отвечает мода `mix`, выделен на рисунке:
file:mode-mix.png

Определение шаблона по моде `mix` (подпредикат `mix`) требуется, когда необходимо выполнить примешивание блока или элемента на уровне шаблонизатора.

***
**NB** Примешивание БЭМ-сущностей выполняется рекурсивно. Иными словами, если для примешиваемой сущности определен шаблон, в котором к ней примешиваются еще какие-либо сущности, все такие сущности добавляются рекурсивно и классы для них появятся в атрибуте `class` базовой сущности (см. пример ниже).
***

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>
{
  block: 'b1'
  js: { p: 1 }
}
        </code></pre>
    </td>
    
    <td>
        <pre><code>
block b1, mix: ({
  block: 'b2', 
  js: { p: 2 }
  })
        </code></pre>
    </td>
    <td>&tdiv class="b1 b2 i-bem" onclick="return { 'b1': { 'p': 1}, 'b2': { 'p': 2} }"&gt;&lt;/div&gt;</td>
</tr>

<tr>
    <td>
        <pre><code>
{
  block: 'b1'
}
        </code></pre>
    </td>
    
    <td>
        <pre><code>
              block b1, mix: [ { block: 'b2' } ]
              block b2, mix: [ { block: 'b3' } ]
            block b3, mix: [ { block: 'b4' } ]
            block b4, mix: [ { block: 'b1' } ]
        </code></pre>
    </td>
    <td>&lt;div class="b1 b2 b3 b4"&gt;&lt;/div&gt;</td>
</tr>
</table>

<a id="jsAttr"></a>

####jsAttr
!!(зел)Тип значения тела шаблона: %%String%%!!
!!(зел)Значение по умолчанию: %%'onclick'%%!!

Мода `jsAttr` определяет имя HTML-атрибута, в значении которого будут переданы параметры клиентского JavaScript для данного блока. По умолчанию используется атрибут `onclick`. Фрагмент HTML, за генерацию которого отвечает мода `jsAttr`, выделен на рисунке:
file:mode-jsattr.png

Определение шаблона по моде `jsAttr` (подпредикат `jsAttr`), необходимо в том случае, если требуется передавать параметры JavaScript в нестандартном атрибуте. Например, для тач-сайтов в этих целях используется атрибут `ondblclick`.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>
{
  block: 'b1',
  js: true
}
        </code></pre>
    </td>
    
    <td><code>block b1, jsAttr: 'ondblclick'</code></td>
    <td>&lt;div class="b1 i-bem" ondblclick="return {'b1': {} }"&gt;&lt;/div&gt;</td>
</tr>
</table>

<a id="attrs"></a>

#### attrs
!!(зел)Тип значения тела шаблона: `Object`!!
!!(зел)Значение по умолчанию: `{}`!!

Мода `attrs` позволяет задать имена и значения произвольных HTML-атрибутов для данного элемента. По умолчанию дополнительные атрибуты не генерируются. Фрагмент HTML, за генерацию которого отвечает мода `attrs`, выделен на рисунке:
file:mode-attrs.png

Значением тела шаблона для данной моды должен быть объект (хэш), содержащий имена и значения атрибутов в качестве пар ключ—значение. В качестве ключа должен выступать валидный идентификатор HTML-атрибута, а в качестве значения — строка или число. При выводе HTML специальные символы в значениях атрибутов экранируются вспомогательной функцией `this._.attrEscape()`.

***
**NB** Если в качестве значения атрибута указать `undefined`, этот атрибут не будет выведен в HTML-элементе.
***

Определение шаблона по моде `attrs` (подпредикат `attrs`) необходимо во всех случаях, когда требуется:

  * добавить произвольные HTML-атрибуты на уровне шаблонизатора;
  * исключить указанные атрибуты из вывода, даже если они были определены во входном BEMJSON. 

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code> 
{
  block: 'logo',
}
        </code></pre>
    </td>

    <td>
        <pre><code>
 block logo {
  tag: 'img'
  attrs: ({alt: 'logo', href: 'http://...'})  
}
        </code></pre>
    </td>
    <td>&lt;img alt="logo" href="http://..." /&gt;</td>
</tr>

<tr>
    <td>
        <pre><code>
{
  block: 'input',
  disabled: true
}
        </code></pre>
    </td>

    <td>
        <pre><code>
block input {
  tag: 'input'
  attrs: ({ disabled: this.ctx.disabled ? 'disabled' : undefined })
}
        </code></pre>
    </td>
    <td>&lt;input class="input" disabled="disabled"/&gt;</td>
</tr>

<tr>
    <td>
        <code>{ block: 'input'}</code>
    </td>

    <td>Тот же шаблон</td>
    <td>&lt;input class="input"/&gt;</td>
</tr>
</table>

<a id="content"></a>

#### content
!!(зел)Тип значения тела шаблона: `BEMJSON`!!
!!(зел)Значение по умолчанию: `this.ctx.content`!!

В рамках моды `content` вычисляется содержимое HTML-элемента, в качестве которого может выступать произвольный BEMJSON (как строка или число, так и дерево БЭМ-сущностей). В качестве значения по умолчанию используется значение поля `content` контекстной БЭМ-сущности (`this.ctx.content`).

Фрагмент HTML, за генерацию которого отвечает мода `content`, выделен на рисунке:
file:mode-content.png

Определение шаблона по моде `content` (подпредикат `content`) необходимо, если: 

  * Необходимо на уровне шаблонизатора добавить содержимое для сущности, у которой отсутствует `content` во входном BEMJSON.
  * Необходимо подменить содержимое сущности на уровне шаблонизатора.

<table>
<tr>
    <th>Входные данные</th>
    <th>Шаблон</th>
    <th>HTML-результат</th>
</tr>

<tr>
    <td>
        <pre><code>
{
  block: 'b1'
}
        </code></pre>
    </td>
    <td>
        <pre><code>
block b1, content: ({
  block: 'b2'
  })
        </code></pre>
    </td>

    <td>&lt;div class="b1"&gt;&lt;div class="b2"&gt;&lt;/div&gt;&lt;/div&gt;</td>
</tr>
</table>


**См. также**:

* [Наследование](#inheritage)
* [Добавление БЭМ-сущностей для задач верстки](#additionbem)

<a id="context_field"></a>
### Поля контекста
В процессе работы шаблонизатор BEMHTML строит структуру данных, содержащую сведения об обрабатываемом узле BEMJSON и о состоянии процесса обработки. Помимо этого в контексте доступен ряд вспомогательных функций BEMHTML.

В момент выполнения шаблона контекст доступен в виде объекта, обозначаемого ключевым словом `this`. Обращение к контексту возможно как в предикате, так и в теле шаблона.

Автор шаблонов имеет возможность определить любые дополнительные поля в контексте.

Все поля контекста можно разделить на две категории: 

  * **Контекстно-зависимые**, значение которых изменяется в зависимости от обрабатываемого узла и фазы процесса обработки.
  * **Контекстно-независимые**, значение которых постоянно.

**См. также**:

  * [Контекст](#context)

<a id="contextdependent"></a>

#### Контекстно-зависимые поля

<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this.block</code></td>
    <td><code>String</code></td>
    <td>Имя блока (контекстной БЭМ-сущности).</td>
</tr>
<tr>
    <td><code>this.elem</code></td>
    <td><code>String</code></td>
    <td>Имя элемента (контекстной БЭМ-сущности).</td>
</tr>
<tr>
    <td><code>this.mods</code></td>
    <td><code>Object</code></td>
    <td>Модификаторы блока (контекстной БЭМ-сущности), <code>имя_модификатора: значение_модификатора</code>.</td>
</tr>
<tr>
    <td><code>this.elemMods</code></td>
    <td><code>Object</code></td>
    <td>Модификаторы элемента (контекстной БЭМ-сущности), <code>имя_модификатора: значение_модификатора</code>.</td>
</tr>
<tr>
    <td><code>this.ctx</code></td>
    <td><code>BEMJSON</code></td>
    <td>Фрагмент входного BEMJSON-дерева, содержащий обрабатываемый узел и его потомков в неизмененном виде. Используется для получения доступа к произвольным полям данных входного BEMJSON.</td>
</tr>
<tr>
    <td><code>this.position</code></td>
    <td><code>Number</code></td>
    <td>Номер позиции текущей сущности среди ее сиблингов во входном BEMJSON-дереве (начиная с 1).</td>
</tr>

<tr>
    <td><code>this._mode</code></td>
    <td><code>String</code></td>
    <td>Текущая мода. Если необходимо определить собственные (нестандартные) моды, в соответствующем шаблоне следует присваивать этому полю имя моды в момент входа в нее. </td>
</tr>
<tr>
    <td><code>this._buf</code></td>
    <td><code>Array</code></td>
    <td>Буфер HTML-результата. Обычно используется только для записи готовых HTML-фрагментов с использованием метода <code>this._buf.push()</code>.</td>
</tr>
<tr>
    <td><code>this.isFirst()</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данная БЭМ-сущность первой среди сиблингов во входном БЭМ-дереве..</td>
</tr>

<tr>
    <td><code>this.isLast()</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данная БЭМ-сущность последней среди сиблингов во входном БЭМ-дереве. Подробнее см. <a href="#algorithmbem">Алгоритм вычисления позиции БЭМ-сущности</a>.</td>
</tr>

<tr>
    <td><code>this.generateId()</code></td>
    <td><code>Number</code></td>
    <td>Возвращает уникальный идентификатор для текущего контекста. Используется, когда нужно сгенерировать HTML-элементы, связанные с помощью атрибута <code>id</code>.</td>
</tr>
</table>

***
**NB**
Ключевые слова для проверки БЭМ-сущностей в предикате являются сокращенной записью для проверки значений полей `block`, `elem` и т.д. в текущем контексте. Например, подпредикат `block b1` эквивалентен подпредикату `this.block === 'b1'`.

Аналогично, ключевые слова для проверки моды в предикате являются сокращенной записью для проверки значения служебного поля `_mode` в текущем контексте. Например, подпредикат`tag` эквивалентен подпредикату `this._mode === 'tag'`.
***

<a id="#extensionbem"></a>

##### Достраивание БЭМ-сущностей по контексту
В BEMJSON принято записывать БЭМ-сущности в свернутом виде. Например, если в блок `menu` вложен элемент `item`, в объекте, описывающем пункт меню, не указывается имя содержащего его блока меню:

<pre><code>
{    
  block: 'menu',     
  content: {     
    elem: 'item'     
    }     
}
</code></pre>

Информация о том, что элемент `item` принадлежит блоку `menu`, достраивается по контексту (на основании вложенности) в процессе работы шаблонизатора. В момент, когда контекстной сущностью является блок `menu`, в полях контекста будут выставлены следующие значения:

<pre><code>
this.block: 'menu'    
this.ctx.block: 'menu'
</code></pre>

В момент входа во вложенный элемент `item`, в поле `this.block` достраивается значение`menu`. В то же время в поле `this.ctx.block` находится значение `undefined`, так как во входном BEMJSON это поле в элементе `item` не определено:

<pre><code>
this.block: 'menu'    
this.elem: 'item'    
this.ctx.block: undefined    
this.ctx.elem: 'item'
</code></pre>

Достраивание выполняется также для элементов, примешанных внутри блоков. Например, в приведенном БЭМ-дереве:

`{ block: 'b1', mix: { elem: 'e1' } }`

В примешанном элементе будет достроено имя блока:

`{ block: 'b1', mix: { block: 'b1', elem: 'e1' } }`

Достраивание БЭМ-сущностей необходимо для корректного срабатывания предикатов на элементы блоков вида `(js)block menu, elem item`, так как в таких предикатах проверяются значения полей контекста `this.block` и `this.elem`.

***
**NB** Чтобы избежать срабатывания предикатов вида `block menu` внутри вложенных в блок элементов, на этапе компиляции шаблонов к таким предикатам в необходимых случаях автоматически добавляется подпредикат `!this.elem`. Автоматическое добавление может не сработать, если предикат шаблона содержит подпредикат с произвольным условием, записанный не в [канонической форме XJST](#xjst-canonical).
***

<a id="algorithmbem"></a>

##### Алгоритм вычисления позиции БЭМ-сущности
Позиция в БЭМ-дереве (поле контекста `this.position`) представляет собой натуральное число, соответствующее порядковому номеру текущей (контекстной) БЭМ-сущности среди ее сиблингов в БЭМ-дереве (одноранговых сущностей). 

При вычислении позиции: 

  * Нумеруются только те узлы обрабатываемого BEMJSON, которые соответствуют БЭМ-сущностям, прочим узлам не соответствует никакой номер позиции.
  * Позиции нумеруются начиная с 1.
  * Нумерация производится в порядке обхода дерева (уплощенный список иерархического представления BEMJSON).

Пример нумерации позиций во входном БЭМ-дереве:

<pre><code>
{    
  block: 'page',         // this.position === 1    
  content: [
    { block: 'head' },   // this.position === 1    
    { block: 'menu',     // this.position === 2    
      content: [ 
        { elem: 'item' }, // this.position === 1    
        { elem: 'item' }, // this.position === 2    
        { elem: 'item' }  // this.position === 3    
      ]    
    },    
    'text'              // this.position === undefined    
  ]   
}
</code></pre>

***
**NB** БЭМ-дерево может быть достроено в процессе выполнения шаблонов с помощью шаблонов по моде `content` и шаблонов по пустой моде. Такое динамическое изменение БЭМ-дерева учитывается при вычислении позиции.
***

Функция определения последней БЭМ-сущности среди сиблингов `this.isLast()` **не сработает** в том случае, если в массиве, содержащем одноранговые БЭМ-сущности, последний элемент не является БЭМ-сущностью. Например:

<pre><code>
{    
  block: 'b1',   
  content: [    
    { block: 'b2' },   
    { block: 'b3' }, // this.isLast() === false   
    'text'    
  ]    
}
</code></pre> 

Такое поведение объясняется тем, что в целях оптимизации BEMHTML не выполняет предварительного полного обхода БЭМ-дерева. Поэтому в момент обработки блока `b3` уже известна длина массива (`b3` не является последним элементом), но еще не известно, что последний элемент не является БЭМ-сущностью и не получит номера позиции.

На практике описанный случай некорректного срабатывания `this.isLast()` не должен порождать ошибок, так как проверка на первую/последнюю БЭМ-сущность обычно применяется к автоматически сгенерированным спискам сущностей, в которые не имеет смысла включать данные других типов.

<a id="context_independent></a>

#### Контекстно-независимые поля
Все контекстно-независимые поля сгруппированы в объекте `this._` и представляют собой вспомогательные функции, используемые при работе шаблонизатора. Автор шаблонов также может пользоваться этими функциями как в теле шаблонов, так и в предикатах.

<table>
<tr>
    <th>Поле</th>
    <th>Тип значения</th>
    <th>Описание</th>
</tr>
<tr>
    <td><code>this._.isArray(Object)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данный объект массивом.</td>
</tr>
<tr>
    <td><code>this._.isSimple(Object)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, является ли данный объект примитивным JavaScript типом.</td>
</tr>
<tr>
    <td><code>this._.isShortTag(String)</code></td>
    <td><code>Boolean</code></td>
    <td>Проверяет, принадлежит ли указанное имя тега к списку коротких тегов (не требующих закрывающего элемента и рекурсивной обработки). Полный список которких тегов:<code>area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, wbr</code>.</td>
</tr>
<tr>
    <td><code>this._.extend(Object, Object)</code></td>
    <td><code>Object</code></td>
    <td>Возвращает хэш, объединяющий содержимое двух хэшей, переданных в качестве аргументов. Если хэши содержат совпадающие ключи, в результат записывается значение из хэша, переданного в качестве второго аргумента.</td>
</tr>
<tr>
    <td><code>this._.xmlEscape(String)</code></td>
    <td><code>String</code></td>
    <td>Возвращает переданную строку с заэкранированными управляющими символами XML <code>[&<>]</code>.</td>
</tr>
<tr>
    <td><code>this._.attrEscape(String)</code></td>
    <td><code>String</code></td>
    <td>Экранирует значение управляющих символов для значений XML- и HTML-атрибутов  (<code>"[&<>]</code>).</td>
</tr>

</table>

<a id="examples"></a>
### Примеры и рецепты

<a id="bringing_input"></a>
#### Приведение входных данных к формату, ориентированному на представление

##### Задача
Сформировать входное БЭМ-дерево для страницы френдленты (список постов с указанием информации об авторе), удобное для обработки в терминах шаблонов BEMHTML. Такое дерево должно быть ориентировано на представление, т.е. набор и порядок БЭМ-сущностей должен соответствовать набору и порядку DOM-узлов выходного HTML.

##### Решение
Приведение к формату, ориентированному на представление, должно производиться вне BEMHTML, на уровне подготовки данных в бэкенде. Такой бэкенд обычно работает с нормализованными данными (data-ориентированный формат). В случае френдленты формат исходных данных может быть таким:

`{    
    posts: [ { text: 'post text', author: 'login' }, … ],    
    users: { 'login': { userpic: 'URL', name: 'Full Name' }, … },    
}`

Данные представлены как два списка объектов разных типов. В списке постов используется только идентификатор пользователя, а полная информация о пользователе находится в соответствующем хеше в списке пользователей.

Формат данных, ориентированный на представление, предполагает денормализацию данных, т.е. развертывание списка постов таким образом, чтобы в каждом посте содержалась полная информация об авторе, даже если в списке присутствует несколько постов одного автора. В BEMJSON подобный формат может выглядеть так:

<pre><code>
{    
    block: 'posts',    
    content: [     
        {    
            block: 'post',    
            content: [    
                { block: 'userpic', content: 'URL' },    
                { block: 'user', content: 'Full Name' },    
                { elem: 'text', content: 'post text' }    
            ]    
        },    
        …    
    ]    
}
</code></pre>

<a id="select_template"></a>

#### Выбор шаблона по условию
##### Задача
Блок `b-link` встречается в двух разновидностях:
 
  * `{ block: 'b-link', content: 'ссылка без URL' }`
  * `{ block: 'b-link', url: '//ya.ru', content: 'ссылка с URL' }`

Необходимо по-разному оформить выходной HTML-элемент в зависимости от наличия/отсутствия поля `url` в данных блока.

##### Решение
Следует сделать проверку на наличие поля `url` подпредикатом шаблона: выражение `this.ctx.url` будет истинным, только если поле `url` определено. 

<pre><code>
block b-link {
  tag: 'span'
  this.ctx.url {
    tag: 'a'
    attrs: { href: this.ctx.url }
  }
}
</code></pre>

**Неправильно** использовать для решения этой задачи условные конструкции JavaScript в теле шаблона:

`` block b-link, tag: this.ctx.url ? 'a' : 'span' ``

При компиляции это выражение не будет оптимизировано, что отрицательно скажется на скорости работы шаблона.

**См. также**:

  * [Синтаксис шаблонов](#template)

<a id="inheritage"></a>

#### Наследование
##### Задача
На разных [уровнях переопределения](http://bem.github.com/bem-method/pages/beginning/beginning.ru.html#Urovnipereopredeleniy) определены два различных шаблона на одну и ту же БЭМ-сущность (`block b1`). Каждый из шаблонов определяет своё содержимое по моде `content`.

Необходимо на втором уровне переопределения **унаследовать** содержимое, определённое на первом уровне, и добавить дополнительное. Требуется аналог `<xsl:apply-imports/>`.

##### Решение
В BEMHTML есть аналог `<xsl:apply-imports/>`. Реализация основывается на возможности заново запустить в шаблоне процедуру применения шаблонов к текущему контексту (`apply()`). Таким образом можно вызвать тот шаблон, который был определен для данного контекста (БЭМ-сущности, моды и т.п.) ранее или на другом уровне переопределения.

При вычислении выражения `apply()` возвращается результат, полученный в ходе применения ранее определенного шаблона. Для избежания бесконечного цикла необходимо добавить подпредикат проверки наличия в контексте какого-то флага (например, `_myGuard`), который будет выставлен при выполнении `apply()`.

<pre><code>
// шаблон на первом уровне переопределения   
block b1, content: 'text1'   

// шаблон на втором уровне переопределения   
block b1, content, !this._myGuard: [
    apply(this._myGuard = true), // получаем предыдущее значение content
    'text2'
]
</code></pre>

В результате применения шаблонов к блоку `b1` будет получен HTML:

`<div class="b1">text1text2</div>`

В bem-bl версии 0.3 добавлена конструкция `applyNext`, которая автоматически генерирует уникальное имя флага против зацикливания.

<pre><code>
block b1, content: 'text1'

block b1, content: [
    applyNext(), // получаем предыдущее значение content
    'text2'
]
</code></pre>

**См. также**:

  * [Конструкция applyNext](#applynext)


<a id="wrappingunit"></a>

#### Оборачивание блока в другой блок
##### Задача
Необходимо вложить блок (`b-inner`) в другой блок (`b-wrapper`) при выполнении шаблона. Таким образом, одному входному блоку будет соответствовать два вложенных друг в друга блока.

##### Решение
При обработке блока `b-inner` в шаблоне по моде `default` (генерация целого элемента) следует модифицировать фрагмент входного дерева `this.ctx`, куда и добавляется блок `b-wrapper` и рекурсивно запустить вызов шаблонов по пустой моде `apply(this._mode = "")`.

Для избежания бесконечного цикла необходимо при вызове выражения `apply()` проверять наличие в контексте специального флага (`_wrap`), который будет выставлен при выполнении `apply()`.

<pre><code>
block b-inner, default, !this.ctx._wrap: apply(
   this._mode = "",
   this.ctx._wrap = true
   this.ctx = {
       block: 'b-wrapper',
       content: this.ctx
   }
)
</code></pre>

В bem-bl начиная с версии 0.3 добавлена конструкция `applyCtx()`, которая автоматически добавляет флаг от зацикливания, присваивает `this.ctx` и применяет шаблоны по пустой моде:

`block b-inner, default: applyCtx({ block: 'b-wrapper', content: this.ctx })`

***
**NB** Конструкцию `applyCtx()` можно применять для **замены** БЭМ-сущности в исходном дереве, если не использовать исходное содержимое блока (`this.ctx`) в аргументе `applyCtx()`.
***

**См. также**:

  * [Конструкция applyCtx](#applyctx)

<a id="additionbem"></a>

#### Добавление БЭМ-сущностей для задач вёрстки
##### Задача
Необходимо сверстать блок с закруглёнными уголками, работающий во всех браузерах (без использования CSS3).

Входной BEMJSON может быть таким:

`{ block: 'box', content: 'text' }`

Реализация уголков требует добавления к блоку четырех дополнительных элементов. Поскольку данные элементы отражают детали HTML-верстки, ими не следует загромождать входное БЭМ-дерево. Добавить эти элементы следует на уровне BEMHTML-шаблона. Финальное БЭМ-дерево должно выглядеть так:

<pre><code>
{    
    block: 'box',    
    content: {    
        elem: 'left-top',    
        content: {    
            elem: 'right-top',    
            content: {    
                elem: 'right-bottom',    
                content: {    
                    elem: 'left-bottom',    
                    content: 'text'    
                }    
            }    
        }    
    }    
}
</code></pre>


##### Решение
Для модификации входного БЭМ-дерева на уровне BEMHTML потребуется написать шаблон по моде `content` для блока `box`. Подмена фрагмента входного БЭМ-дерева (добавление необходимых элементов) выполняется с помощью конструкции `applyCtx()`, а подстановка исходного содержимого — с помощью конструкции `applyNext()`
BEMHTML-шаблон, выполняющий это преобразование:


<pre><code>
block box, content: applyCtx({    
    elem: 'left-top',    
    content: {    
        elem: 'right-top',    
        content: {    
            elem: 'right-bottom',   
            content: {    
                elem: 'left-bottom',   
                content: applyNext()   
            }    
        }    
    }    
})
</code></pre>


В bem-bl начиная с версии 0.3 добавлен короткий синтаксис для применения шаблонов по моде:

`block b-source, default: apply("", this.ctx.block = 'b-target')`

**См. также**:

  * [Конструкция apply](#apply)
  * [Конструкция applyNext]((#applynext)
  * [Конструкция applyCtx]((#applyctx)

<a id="usebem"></a>
#### Использование позиции БЭМ-сущности
##### Задача
Необходимо пронумеровать пункты меню, начиная с 1. В текст каждого элемента меню нужно добавить его порядковый номер с точкой.

##### Решение
Используем механизм вычисления позиции БЭМ-сущности среди сиблингов (поле контекста `this.position`).
Входные данные могут выглядеть так:

<pre><code>
{    
  block: 'menu',    
  content: [    
    { elem: 'item', content: 'aaa' },    
    { elem: 'item', content: 'bbb' },    
    { elem: 'item', content: 'ccc' },    
  ]    
}
</code></pre>


Для выполнения нумерации следует написать шаблон по моде `content` на пункт меню, в котором содержание элемента будет составлено из номера позиции, разделителя (точки с пробелом) и исходного текста элемента (полученного с помощью конструкции `applyNext()`): 

<pre><code>
block menu {   
  tag: 'ul'    
  elem item {    
    tag: 'li'    
    content: [    
      this.position, '. ',    
      applyNext()    
    ]    
  }    
}
</code></pre>

**См. также**:

  * [Мода content](#content)
  * [Конструкция applyNext](#applynext)

<a id="check_predicate"></a>

#### Проверка подпредикатов в определенном порядке
##### Задача
Необходимо проверять подпредикаты шаблона в строго определенном порядке, например, сначала проверить наличие в контексте объекта `this.world`, а затем проверить значение поля в этом объекте `this.world.answer`.

##### Решение
Воспользуемся тем, что подпредикат шаблона BEMHTML может быть произвольным JavaScript-выражением и запишем его в следующей форме:
   
`(this.world && this.world.answer === 42)`

Недостаток этого решения в том, что при компиляции это выражение не будет оптимизировано, что отрицательно скажется на скорости работы шаблона. В большинстве случаев можно и нужно избегать необходимости в строгом порядке проверки подпредикатов.


<a id="binding_html"></a>

#### Связывание HTML-элементов по id
##### Задача
Необходимо для входного блока `input` сгенерировать пару HTML-элементов `<label>` и `<input>`, так чтобы значение атрибута `input@id` было сгенерировано автоматически, уникально и совпадало со значением атрибута `label@for`.

Входные данные могут выглядеть так:

<pre><code>
{
  block: 'input',
  label: 'My Input',
  content: 'my value'
}
</code></pre>

##### Решение
Для генерации уникального идентификатора, подходящего в качестве значения атрибута `id`, воспользуемся вспомогательной функцией контекста `this.generateId()`. Чтобы сгенерировать два HTML-элемента на основании одного входного блока, потребуется два шаблона:

  * шаблон по моде `tag`, указывающий пустую строку, чтобы отменить генерацию HTML-элемента для данного блока, но обработать содержимое;
  * шаблон по моде `content`, в котором будут сформированы два необходимых элемента и их атрибуты.

<pre><code>
block input {
  tag: ''
  content: [
    {
      tag: 'label',
      attrs: { 'for': this.generateId() },
      content: this.ctx.label
    },
    {
      tag: 'input',
      attrs: {
        id: this.generateId(),
        value: this.ctx.content
      }
    }
  ]
}
</code></pre>`

<a id="sources"></a>
### Источники
Сборник видео:    
[http://clubs.ya.ru/bem/posts.xml?tag=64664080](http://clubs.ya.ru/bem/posts.xml?tag=64664080)

Рассказ на пЯТЬнице про BEMHTML    
[http://clubs.ya.ru/bem/replies.xml?item_no=898](http://clubs.ya.ru/bem/replies.xml?item_no=898)

Рассказ про XJST:    
[http://clubs.ya.ru/bem/replies.xml?item_no=899](http://clubs.ya.ru/bem/replies.xml?item_no=899)

"BEMHTML. Not yet another шаблонизатор".    
Чем шаблонизатор BEMHTML отличается от сотен других шаблонизаторов и почему мы используем именно его.    
[http://clubs.ya.ru/bem/replies.xml?item_no=1153](http://clubs.ya.ru/bem/replies.xml?item_no=1153)     
[http://clubs.ya.ru/bem/replies.xml?item_no=1172](http://clubs.ya.ru/bem/replies.xml?item_no=1172)   

Шаблонизатор, работающий с несколькими уровнями    
[http://clubs.ya.ru/bem/replies.xml?item_no=1391](http://clubs.ya.ru/bem/replies.xml?item_no=1391)

Предварительная документация    
[http://clubs.ya.ru/bem/replies.xml?item_no=992](http://clubs.ya.ru/bem/replies.xml?item_no=992)    
[http://bem.github.com/bem-bl/pages/bemhtml-syntax/bemhtml-syntax.ru.html](http://bem.github.com/bem-bl/pages/bemhtml-syntax/bemhtml-syntax.ru.html)   

bem-bl: [http://bem.github.com/bem-bl/index.ru.html](http://bem.github.com/bem-bl/index.ru.html)

