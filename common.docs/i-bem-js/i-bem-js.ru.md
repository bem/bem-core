# *i-bem.js*: Руководство пользователя #

## *i-bem.js*: Javascript-фреймворк для БЭМ ##

*i-bem.js* — специализированный JavaScript-фреймворк для веб-разработки
в рамках [БЭМ-методологии](http://ru.bem.info/method/).

*i-bem.js* позволяет:

 * разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
 * описывать логику работы блока в декларативном стиле — как набор состояний;
 * легко интегрировать JavaScript-код с CSS в стиле БЭМ и BEMHTML-шаблонами;
 * гибко переопределять поведение библиотечных блоков.

*i-bem.js* не предназначен:

 * для замены фреймворка общего назначения, подобного jQuery.

**Краткий обзор содержания документа**:

* [Общие сведения](#intro) о фреймворке: связь с понятиями БЭМ-предметной области, краткое описание модульной структуры фреймворка,
  шаблонного проекта, инструментов для сборки кода, написанного с
  использованием *i-bem.js*.

* [Привязка JS-блоков к HTML](#html) — синтаксис указания JS-блоков на
  HTML-странице, типы соотношения HTML-элементов и JS-блоков.

* [Декларация блока](#decl) — синтаксис описания JS-блоков.

* [Работа с DOM-деревом](#dom) — API для работы с DOM-узлами блоков:
  элементы, динамическое изменение DOM-дерева (AJAX).

* [События](#events) — событийная модель *i-bem.js*: DOM-события,
  BEM-события, делегирование событий.

* [Состояния блока](#states) — модификаторы, триггеры на смену
  состояний (установку модификаторов), инициализация экземпляров
  блоков.

* [Взаимодействие блоков](#ibc) — API для обращения из блока к другим блокам.

* [Что дальше?](#docs) — ссылки на документацию и дополнительные материалы.

<a name="intro"></a>

# Общие сведения #

<a name="intro-bem"></a>

## БЭМ-методология и JavaScript ##

С точки зрения БЭМ-методологии веб-интерфейс строится из независимых
**блоков** (внутри которых могут быть выделены **элементы**). И блоки,
и элементы могут иметь состояния, описываемые **модификаторами**.

Работа веб-интерфейса обеспечивается несколькими **технологиями**
(HTML, CSS, JS...). При использовании БЭМ-методологии вся реализация
веб-интерфейса разбита на компоненты по блокам. Описание блока в этой
схеме складывается из нескольких файлов — по одному на каждую
технологию:

 * `my-block.css` — описывает внешний вид блока;
 * `my-block.bemhtml` — шаблоны для генерации HTML-представления блока;
 * `my-block.js` — описывает **динамическое поведение** блока в браузере.

Фреймворк *i-bem.js* позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:

 + **Блок** — JS-компонент, описывающий логику работы однотипных
 элементов интерфейса. Например, все кнопки могут быть реализованы в
 виде блока `button`. Тогда, в соответствии с БЭМ-методологией,
 `button.css` определяет внешний вид всех кнопок, а `button.js` —
 логику их работы.
 + На каждой странице может размещаться более одного **экземпляра
 блока** (например, кнопки). Каждому экземпляру блока соответствует
 JS-объект, динамически создаваемый в памяти браузера и хранящий
 состояние данного экземпляра. JS-объект хранит ссылку на DOM-узел,
 к которому привязан данный экземпляр блока.
 + **Элементы** — DOM-узлы, вложенные в DOM-узел блока и имеющие атрибут
   `class`, указывающий на их роль в БЭМ-предметной области (имя блока
   и элемента). Элементы блока доступны через [JS-API](#elem-api)
   экземпляра блока.
 + **Модификаторы** — хранят информацию о состоянии блока и его
   элементов. Состояние модификаторов записывается в атрибуте `class`
   на DOM-узлах блока и элементов. Управление модификаторами
   производится через [JS-API](#mods-api) экземпляра блока.

<a name="intro-use"></a>

## Как использовать i-bem.js ##

Фреймворк *i-bem.js* входит в состав библиотеки [bem-core](http://github.com/bem/bem-core/).

Реализация *i-bem.js* состоит из двух модулей:

* Модуль [`i-bem`][].<br/>
  Базовая реализация JS-блока i-bem, от которой наследуются все блоки в
  *i-bem.js*. Блок `i-bem` написан с расчетом на использование в любом
  JS-окружении, как на клиенте, так и на сервере (например, в
  Node.js).
* Модуль [`i-bem__dom`][].<br/> Базовая реализация блока, привязанного
к DOM-узлу. Рассчитан на использование на клиенте, опирается на работу
браузеров с DOM. Зависит от `jQuery`.

Зависимости:

 * jQuery (только для модуля `i-bem__dom`). При использовании `bem-core` отдельная установка jQuery не требуется.
 * Модульная система [ymaps/modules][ymaps]. При использовании
   [bem-tools][] с технологией `.browser.js` (и производных от нее)
   эта зависимость удовлетворяется автоматически.

Можно использовать *i-bem.js* как часть полного стека
БЭМ-инструментов. В этом случае свой проект удобно создавать на основе
шаблонного репозитория [project-stub](http://github.com/bem/project-stub/), в котором настроена автоматическая установка зависимых библиотек.

Если не планируется использование других технологий БЭМ-платформы,
достаточно скопировать код библиотеки `bem-core` в существующий проект.

<a name="intro-build"></a>

## Сборка ##

Разработка в рамках БЭМ-методологии ведется модульно — каждый блок
программируется отдельно. Финальный исходный код веб-страниц
формируется из кода отдельных блоков с помощью процедур **сборки**.

В файловой системе блок удобно представлять в виде каталога, а реализацию блока в каждой из технологий — в виде отдельного файла:

```html
    desktop.blocks/
        my-block/
            my-block.css
            my-block.js
            my-block.bemhtml
            ...

    desktop.blocks/
        other-block/
            other-block.css
            other-block.js
            other-block.bemhtml
            ...
```

Для каждой веб-страницы код использованных на ней блоков может быть собран в единые файлы:

```html
    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...
```

Для сборки кода результирующих веб-страниц из отдельных
описаний блоков существует два инструмента:

* [bem-tools](http://github.com/bem/bem-tools/);
* [enb](https://github.com/enb-make/enb) совместно с [enb-modules](https://github.com/enb-make/enb-modules).

<a name="intro-name"></a>

## Почему i-bem.js так называется ##

В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и
гибко настраивать поведение библиотеки на разных уровнях переопределения.

Служебным блокам в БЭМ было принято давать имена с префиксом `i-`. Таким образом, имя `*i-bem.js*`
читается как «реализация блока `i-bem` в технологии `js`».

<a name="html"></a>

# Привязка JS-блоков к HTML #

JavaScript-компоненты в *i-bem.js* служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — привязать обработку определенных событий к
указанному HTML-фрагменту.

При разработке веб-интерфейса в *i-bem.js* первичным «каркасом»
является HTML-дерево документа. В HTML-дереве размечаются точки, к
которым привязаны интерактивные элементы интерфейса — JS-блоки.
Точка привязки JS-блока — HTML-элемент, в атрибуте `class` которого
указано имя блока, а в атрибуте `data-bem` — [параметры блока](#html-syntax).

При загрузке страницы в браузере выполняется
[инициализация блоков](#init). В процессе инициализации создаются
экземпляры блоков — JS-объекты для всех блоков, упомянутых в
HTML-элементах на странице. JS-объект, привязанный к HTML-элементу,
обрабатывает происходящие на нем [DOM-события](#dom-events) и хранит
состояние данного экземпляра блока.

*i-bem.js* дает возможность реализовать JS-компонент, не привязанный к
HTML, — [блок без DOM-представления](#i-blocks). Такой блок предоставляет API, аналогичное обычным JS-блокам.

Описанный подход привязки JavaScript-компонент к HTML имеет следующие преимущества:

 * естественная деградация интерфейса на клиентах с отключенным JavaScript;
 * _прогрессивный рендеринг_ — возможность начать отрисовку элементов
   интерфейса до окончания загрузки всех данных страницы (например,
   изображений).

<a name="html-syntax"></a>

## Синтаксис привязки блоков ##

Чтобы привязать блок к HTML-элементу (например, `<div>...</div>`), необходимо:

 * **Отметить блок в HTML-дереве**.<br/>
 Включить имя блока в список классов HTML-элемента (атрибут `class`).

```html
<div class="my-block">...</div>
```

 * **Инициализировать экземпляр блока**.<br/>
 Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.

```html
<div class="my-block i-bem">...</div>
```

 * **Передать параметры экземпляру блока**.<br/> Поместить параметры
 блока в атрибут `data-bem`. Параметры блока записываются в формате
 JSON и представляют собой хэш вида: __имя блока—хэш параметров__. Параметры
 передаются экземпляру блока в момент инициализации
 ([подробнее...](#data-bem)).

```html
<div class="my-block i-bem" data-bem='{ "my-block": { "name": "ya" } }'>...</div>
```

Одному HTML-элементу не обязательно должен соответствовать один
экземпляр блока. Возможны следующие типы связи между блоками и
HTML-элементами:

* [Один HTML-элемент — один JS-блок](#html-simple);
* [Один HTML-элемент — несколько JS-блоков](#html-mixes);
* [Один JS-блок на нескольких HTML-элементах](#distrib-block);
* [Блоки без DOM-представления](#i-blocks).

<a name="html-simple"></a>

### Один HTML-элемент — один JS-блок ###

Самый простой и распространенный способ привязки блоков к HTML.

**Пример**: HTML-элемент `div`, на котором размещен блок `my-block`, параметры блока — пустой список `{}`.

```html
<div class="my-block i-bem" data-bem='{ "my-block": {} }'>
    ...
</div>
```


<a name="html-mixes"></a>

### Один HTML-элемент — несколько JS-блоков ###

Техника размещения нескольких блоков на одном HTML-элементе в БЭМ-методологии называется **микс**.

**Пример**: HTML-элемент `div`, на котором размещены блок `user` с
параметром `name`: `pushkin` и блок `avatar` с параметром `img`: `http://...`.

```html
<div class="user avatar i-bem"
    data-bem='{
        "user": { "name": "pushkin" },
        "avatar": { "img": "http://..." }
     }'>
     ...
</div>
```

<a name="distrib-block"></a>

### Один JS-блок на нескольких HTML-элементах ###

Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из
нескольких компонентов, состояние которых должно быть согласовано. Например, виджет «вкладки», где клик по заголовку вкладки (один HTML-элемент), меняет содержимое вкладки (другой HTML-элемент). Другой пример — маркер, обозначающий точку на карте (первый элемент) и связанное с ним описание точки в списке рядом с картой (второй элемент).

Чтобы привязать экземпляр блока к нескольким HTML-элементам, нужно в параметрах блока на всех связанных с ним HTML-элементах указать одинаковое значение `id`. В качестве значения `id` может выступать произвольная строка.

**Пример**: Экземпляр блока `notebook` привязан к HTML-элементам `div` и `span`, в параметрах блока указан общий `id` — `maintab`.

```html
<div class="notebook i-bem" data-bem='{ "notebook": { "id": "maintab" }}'>
</div>
...
<span class="notebook i-bem" data-bem='{ "notebook": { "id": "maintab" }}'>
</span>
```

В результате при инициализации блоков создается один JS-объект, поле
 [`{jQuery} domElem`](#domElem) которого содержит ссылки на оба DOM-узла.

Идентификатор `id` используется *только в момент инициализации*
экземпляра блока. Значение `id` должно быть уникальным в пределах
экземпляров одного блока в рамках одной [волны инициализации](#init-wave).


<a name="i-blocks"></a>

### Блоки без DOM-представления ###

Инфраструктурный код, решающий общие задачи интерфейса: связь с
бэкэндом, общие вычисления и т.п. — при работе с *i-bem.js* можно
оформлять в виде блока, как и весь прочий JS-код. Чтобы не привязывать
такие блоки к HTML-дереву искусственно, *i-bem.js* предоставляет
возможность создавать блоки без DOM-представления.

Блоки без DOM-представления:

 * Не указываются в HTML-коде страницы.
 * Декларируются как [доопределение модуля `i-bem`](#bem-decl), а не
   `i-bem__dom`, как блоки с DOM-представлением.
 * Должны быть [инициализированы явно](#init-bem).


### Блоки-миксы
Часто в проекте одна и та же функциональность может быть востребована в нескольких блоках. Например, разные блоки могут обращаться за данными к бэкенду, используя AJAX, или совершать однотипные операции с DOM-деревом и т.д. Чтобы избежать ненужных повторов в коде, общую функциональность можно инкапсулировать в виде модулей, а затем примешивать к блокам.

В *i-bem.js* для добавления востребованной функциональности к блокам, используется специальный тип блоков – **блоки-миксы**. Главная особенность блоков-миксов состоит в том, что они не участвуют в цепочке наследования. Это позволяет примешивать, реализованную в них функциональность к блокам, без риска нарушения их связей с родительскими блоками (вызов базовых методов (`this.__base`) и т.д.).


<a name="data-bem"></a>

## Синтаксис передачи параметров ##

Параметры блока хранятся в атрибуте `data-bem` HTML-элемента и
передаются блоку в момент инициализации.  Параметры позволяют
модифицировать поведение экземпляра блока, привязанного к данному
HTML-элементу.

В значении атрибута `data-bem` указываются параметры *всех JS-блоков, размещенных на данном узле*.
Параметры передаются в формате JSON в виде хэша:

 + ключ — `{String}` имя блока;
 + значение — `{Object}` параметры данного блока. Если данному экземпляру блока не требуются
   параметры, указывается пустой хэш `{}`.

Значение атрибута `data-bem` должно содержать валидный JSON.

Такой формат параметров продиктован следующими соображениями:

 * Указание имени блока в параметрах позволяет избежать необходимости
   парсить значение атрибута `class`, что упрощает и ускоряет
   инициализацию блоков.
 * Это же решение позволяет размещать несколько блоков на одном
   HTML-элементе без необходимости множить атрибуты элемента.

<a name="decl"></a>

# Декларация блока #

JS-реализация блока описывает поведение определенного класса элементов веб-интерфейса. В конкретных
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует
функциональность всего класса и имеет собственное состояние, независимое от остальных.

В терминах парадигмы объектно-ориентированного программирования:

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в _методах_ класса (= блока).
Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в *i-bem.js* принято называть **декларацией**, чтобы подчеркнуть принятый в БЭМ декларативный стиль программирования. Поведение блока программируется в декларативном стиле в виде утверждений: _набор условий — реакция блока_.


## Синтаксис декларации ##

Чтобы декларировать новый JS-блок **с DOM-представлением** (привязанный к HTML-элементу), необходимо доопределить [ymaps][]-модуль `i-bem__dom`.

Блоки декларируются с помощью метода `decl`, принимающим три
параметра:

1. Имя блока `{String}` или [описание блока](#decl-selector) `{Object}`.
2. Методы экземпляра блока — `{Object}`.
3. Статические методы — `{Object}`.

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl(/* имя или описание блока */,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    }
);

provide(DOM);

});
```

-------------------------------------------------------------------------------

**NB:** С точки зрения модульной системы [ymaps][], декларации разных
  блоков представляют собой переопределение одного и того же модуля
  `i-bem__dom`. Однако с точки зрения *i-bem.js* таким образом создаются
  *разные объекты* для построения экземпляров блоков.

-------------------------------------------------------------------------------

<a name="bem-decl"></a>

Блоки, не имеющие DOM-представления, декларируются как доопределение [ymaps][]-модуля `i-bem`.
Для декларации используется метод `decl`, принимающий те же параметры,
что и метод `decl` модуля `i-bem__dom`:

```js
modules.define('i-bem', function(provide, BEM) {

BEM.decl(/* имя или описание блока */,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    }
);

provide(BEM);

});
```


-------------------------------------------------------------------------------

**NB:** Оформлять инфраструктурный код в виде блока без
  DOM-представления удобно, если в нем планируется использовать API
  БЭМ-блоков (состояния, выражаемые модификаторами, BEM-события и
  т. п.). Если использовать БЭМ-предметную область не планируется,
  инфраструктурный код можно оформлять в виде [ymaps][]-модуля.

**Пример**:

```js
modules.define('router', function(provide) {

provide({
    route : function() { /* ... */ }
});

});
```

-------------------------------------------------------------------------------

<a name="decl-selector"></a>


## Описание блока в декларации ##

Первый параметр метода `decl` представляет собой описание блока, в
котором будут применяться объявленные в декларации методы. Описание
обязательно содержит имя блока и может дополнительно содержать:

* ограничение сферы действия декларации определенной модификацией
  блока;
* список родительских блоков, методы которых должен наследовать данный
  блок.

Описание может быть задано в одной из двух форм:

1. Имя блока — строка.<br/>
   Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).

**Пример**: декларация методов для блока `button`.

```js
DOM.decl('button',
    { /* методы экземпляра */ },
    { /* статические методы */ }
);
```

2. Описание блока — хэш.<br/> Содержит имя (и значение)
модификатора. Объявленные методы будут применяться только к тем
экземплярам блока, у которых присутствует данный модификатор (с
указанным значением).

**Пример**: декларация методов для блока `button` с модификатором
`type` в значении `link` (описывает поведение псевдокнопок):

```js
DOM.decl({ block: 'button', modName: 'type', modVal: 'link' },
    { /* методы экземпляра */ },
    { /* статические методы */ }
);
```

-------------------------------------------------------------------------------

**NB:** Если в декларации для блока с указанием конкретных
  модификаторов описаны статические методы, они будут применяться ко всем экземплярам данного блока *вне зависимости от значений
  модификаторов*. Модификаторы являются свойствами экземпляров блоков,
  а статические методы принадлежат классу блока и поэтому не могут
  учитывать ограничения по модификатору.

-------------------------------------------------------------------------------


### Описание блока-микса в декларации

Чтобы подмешать к блоку один или несколько блоков-миксов, нужно в описании блока присвоить значение опциональному полю `baseMix`.  Значением должен выступать массив имен, примешиваемых блоков-миксов:

```js
DOM.decl({ block: 'myblock', baseMix: ['foo', 'bar']},
    { /* методы экземпляра */ },
    { /* статические методы */ }
);
```
#### Декларация блока-микса

В качестве блоков-миксов можно использовать только блоки, задекларированные с помощью `declMix`. Этот метод принимает декларацию блока в формате, аналогичном методу `decl`:

```js
BEM.declMix('mymix',
    { /* свойства и методы экземпляра */ },
    { /* статические свойства и методы */ }
);
```

-------------------------------------------------------------------------------

**NB:** Первым аргументом в декларации блока-микса всегда выступает строка – имя блока. Это связано с тем, что для блоков-миксов не предполагаются возможности использования модификаторов или примешивания блоков.

-------------------------------------------------------------------------------


###

## Контекст ##

**Методы экземпляра блока** исполняются в контексте JS-объекта
экземпляра блока. Соответственно, ключевое слово `this` в методах
экземпляра блока ссылается на JS-объект **экземпляра блока**.

**Статические методы** исполняются в контексте JS-объекта,
  соответствующего классу блока. Соответственно, ключевое слово `this`
  в статических методах блока ссылается на **класс блока**, а не на
  экземпляр.

Контекст содержит зарезервированные поля:

 + `this.__self`: Ссылается на статические методы класса, к которому
   принадлежит экземпляр. Определен в методах экземпляра блока. Для
   статических методов не имеет смысла и не определен.

    **Пример**: Вызов статического метода `staticMethod` в методе
    `onEvent` экземпляра блока `my-block`.

```js
DOM.decl('my-block', {
    onEvent: function() {
        this.__self.staticMethod(); // вызов статического метода
        this.doMore();
    },
    {
        staticMethod: function() { /* ... */ }; // определение статического метода
    }
});
```

 + `this.__base`: Ссылается на реализацию метода в базовом классе, от которого наследуется данный.
    Позволяет выполнить super call. Определен в методах экземпляра
    блока и в статических методах блока.

    **Пример**: вызов (и модификация) метода `_onClick` родительского класса (базовой реализации метода в классе `button`).

```js
DOM.decl({ block: 'my-button', baseBlock: 'button' }, {
    _onClick: function() {
        this.__base();
        this.doMore();
    }
);
```

-------------------------------------------------------------------------------

**NB:** Так как блоки-миксы не участвуют в цепочке наследования, внутри них нельзя использовать `__base`, для обращения к родительскому блоку.


-------------------------------------------------------------------------------

**NB:** При разработке блоков с использованием *i-bem.js* внутренним
  методам блока, не предназначенным для использования извне, принято
  давать имена, начинающиеся с символа подчеркивания. Например,
  `_onClick`.

-------------------------------------------------------------------------------

<a name="dom"></a>

# Работа с DOM-деревом #

<a name="domElem"></a>

## DOM-узел экземпляра блока ##

Все экземпляры блоков, привязанные к DOM-дереву, содержат в поле
`{jQuery} this.domElem` jQuery-объект, ссылающийся на один или
несколько DOM-узлов, с которыми связан данный экземпляр блока.

<a name="elem-api"></a>

## Элементы ##

БЭМ-элементы блоков представлены в *i-bem.js* как DOM-узлы, вложенные
в DOM-узел экземпляра блока. Для обращения к DOM-узлам элементов и
работы с их модификаторами, следует использовать API, предоставляемый
экземпляром блока.

Экземпляр блока предоставляет два метода для обращения к элементам данного экземпляра:

* Кеширующий доступ: `elem(elems, [modName], [modVal])`. Элемент,
  полученный таким образом, не требуется сохранять в переменную.

```js
DOM.decl('b-link', {
    setInnerText: function() {
        this.elem('inner').text('Текст ссылки');
        /* ... */
        this.elem('inner').text('Другой текст');
    }
);
```

* Некеширующий доступ: `findElem(elems, [modName], [modVal])`.

```js
DOM.decl('b-link', {
    setInnerText: function() {
        var inner = this.findElem('inner');
        inner.text('Текст ссылки');
        /* ... */
        inner.text('Другой текст');
    }
});
```

При [динамическом добавлении и удалении элементов блока](#dynamic) может
возникнуть необходимость сброса кеша элементов. Для этого предназначен
метод `dropElemCache('elements')`. В качестве параметра указывается
разделенный пробелами список имен элементов, кеш для которых нужно
сбросить:

```js
DOM.decl('attach', {
    clear: function() {
        DOM.destruct(this.elem('control'));
        DOM.destruct(this.elem('file'));
        return this.dropElemCache('control file');
    }
});
```


Полное описание API для работы с элементами содержится в
исходном коде модуля [`i-bem__dom`][].

<a name="dynamic"></a>

## Динамическое обновление блоков и элементов в DOM-дереве ##

В современных интерфейсах зачастую необходимо создавать новые
фрагменты DOM-дерева и заменять старые в процессе работы (AJAX). В
*i-bem.js* предусмотрены следующие функции для добавления и замены
фрагментов DOM-дерева.

* Добавить DOM-фрагмент:

  * `append` —  в конец указанного контекста;
  * `prepend` — в начало указанного контекста;
  * `before` — перед указанным контекстом;
  * `after` — после указанного контекста;

* Заместить DOM-фрагмент:

  * `update` —  внутри указанного контекста;
  * `replace` — заменить указанный контекст новым DOM-фрагментом.

Все функции автоматически выполняют [инициализацию блоков на
обновленном фрагменте DOM-дерева](#init-ajax).

Чтобы упростить создание БЭМ-сущностей на обновляемых фрагментах
DOM-дерева, можно использовать шаблонизатор
[BEMHTML](http://ru.bem.info/articles/bemhtml-reference/), подключив
его в качестве [ymaps][]-модуля.  БЭМ-сущности описываются в формате
[BEMJSON](http://ru.bem.info/articles/bemhtml-reference#bemjson)
непосредственно в коде блока.  Функция `BEMHTML.apply` генерирует
HTML-элементы по BEMJSON-описанию в соответствии с правилами
именования БЭМ.

**Пример**: В методе `_updateFileElem` блока `attach` выполняется
  удаление элемента `file`, если он существовал, и генерация нового
  элемента с помощью функции `BEMHTML.apply`:

```js
modules.define(
    'i-bem__dom',
    ['BEMHTML', 'strings__escape'],
    function(provide, BEMHTML, escape, DOM) {

DOM.decl('attach', {
    _updateFileElem : function() {
        var fileName = extractFileNameFromPath(this.getVal());
        this.elem('file').length && DOM.destruct(this.elem('file'));
        DOM.append(
            this.domElem,
            BEMHTML.apply({
                block : 'attach',
                elem : 'file',
                content : [
                    {
                        elem : 'icon',
                        mods : { file : extractExtensionFromFileName(fileName) }
                    },
                    { elem : 'text', content : escape.html(fileName) },
                    { elem : 'clear' }
                ]
            }));
        return this.dropElemCache('file');
    }
});

provide(DOM);

});
```

<a name="events"></a>

# События #

В *i-bem.js* поддерживается два вида событий:

<a name="dom-events"></a>

* **DOM-событие** — JavaScript-событие на DOM-узле, связанном с
  блоком. Отражает взаимодействие пользователя с интерфейсом (клик,
  наведение мыши, ввод текста и т.п.). DOM-событие обычно обрабатывает
  тот экземпляр блока, на DOM-узле которого оно возникло.
* **BEM-событие** — собственное событие, генерируемое
  блоком. Позволяет организовать API для
  [взаимодействия с блоком](#ibc). BEM-события обычно обрабатывает
  экземпляр блока, отслеживающий состояние других блоков, на которых
  генерируются события.

Планируя архитектуру интерфейса, нужно учитывать, что DOM-события
следует использовать только во *внутренних* процедурах блока. Для
взаимодействия блока с *внешней* средой (другими блоками),
предназначены BEM-события.


-------------------------------------------------------------------------------

**NB:** Работа с DOM-событиями полностью реализована средствами
  фреймворка jQuery.

-------------------------------------------------------------------------------


<a name="delegated-events"></a>

## Делегирование событий ##

Обработка BEM- и DOM-событий может быть **делегирована** контейнеру
(всему документу или конкретному DOM-узлу). В этом случае контейнер
служит точкой обработки событий, возникающих на любом из
дочерних узлов контейнера, даже если в момент подписки на события
некоторые из дочерних узлов еще не существовали.

Например, блок меню может содержать вложенные блоки (или элементы — в
зависимости от конкретной реализации блока) — пункты меню. Обработку
кликов на пунктах меню имеет смысл делегировать самому блоку
меню. Это, во-первых, позволяет сэкономить затраты ресурсов на
подписку на события (дешевле подписаться на одно событие контейнера,
чем на много событий элементов). Во-вторых, это дает возможность более
гибко изменять состав меню: добавлять и удалять пункты, не выполняя
при этом подписку на события добавленных пунктов меню и отмену
подписки на события удаленных.

* [**Делегирование DOM-событий**](#dom-events-delegated) можно
  использовать для обработки DOM-событий, происходящих на DOM-узле
  экземпляра блока или на DOM-узлах его элементов. Делегирование
  DOM-событий может выполняться либо для всех экземпляров блоков
  данного типа в пределах документа, либо только для экземпляров
  блоков внутри указанного контекста (фрагмента HTML-дерева).

    Контейнером, которому делегируется обработка DOM-событий, всегда
    выступает `window.document`.


* [**Делегирование BEM-событий**](#bem-events-delegated) следует
  использовать для обработки событий на *экземплярах блоков*,
  содержащихся внутри указанного DOM-узла.

    Контейнером, которому делегируется обработка BEM-событий, может
    служить **произвольный DOM-узел**. По умолчанию в качестве
    контейнера выступает весь документ (`window.document`). Часто блок
    обрабатывает BEM-события вложенных блоков, тогда в качестве
    контейнера следует указать DOM-узел блока-обработчика
    [`this.domElem`](#domElem).


Полный список хелперов для подписки на делегированные события
можно найти в исходном коде модуля [`i-bem__dom`][].


## DOM-события ##

Для подписки на DOM-события на узлах, связанных с блоком или
элементом, используются метод экземпляра блока `bindTo([elem], event,
handler)`.

**Пример**: В момент [инициализации экземпляра блока](#init)
`my-block` выполняется подписка на событие `click`, при наступлении
которого блок выставляет себе [модификатор](#modifier) `size` в
значение `big`.

```js
DOM.decl('my-block', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this.bindTo('click', function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.domElem
                    this.setMod('size', 'big');
                });
            }
        }
    }
});
```

**Пример**: При [инициализации экземпляра блока](#init) `my-form` выполняется
  подписка на событие `click` элемента `submit`, при наступлении
  которого будет вызван метод экземпляра блока `_onSubmit`.

```js
DOM.decl('my-block', {
    onSetMod : {
        'js' : {
            'inited': function() {
                this.bindTo('submit', 'click', function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.elem('submit')
                    this._onSubmit();
                });
            }
        }
    },

    _onSubmit : function() { /* ... */ }
});
```

-------------------------------------------------------------------------------

**NB:** Функция-обработчик выполняется в контексте того экземпляра
  блока, в котором возникло событие.

-------------------------------------------------------------------------------

**Удаление подписки** на DOM-события выполняется автоматически при
уничтожении экземпляра блока. Если необходимо удалить подписку вручную
в процессе работы блока, следует использовать метод
`unbindFrom([elem], event, handler)`.

<a name="dom-events-delegated"></a>

### Делегирование DOM-событий ###

Делегирование обработки DOM-событий выполняется с помощью метода
`liveBindTo([elem], event, handler)`. В декларации блока точкой,
зарезервированной для подписки на делегированные DOM-события, служит
свойство `live` в разделе статических методов блока.

**Пример**: Все экземпляры блока `menu` подписываются на
  делегированное DOM-событие `click` своих элементов `item`. Метод
  `_onItemClick` экземпляра блока `menu` будет выполняться при клике
  на любой пункт (элемент `item`) в этом меню. Не имеет значения,
  существовал ли этот пункт в момент инициализации экземпляра блока.

```js
DOM.decl('menu', {
    _onItemClick : function(e) {
        var clickedItem = $(e.currentTarget); // элемент 'item' блока 'menu', на котором слушается DOM-событие 'click'
    }
}, {
    live : function() {
        this.liveBindTo('item', 'click', function() {
            this._onItemClick();
        });
        return false; // если инициализация блока не может быть отложена
    }
});
```

По умолчанию при наличии в декларации блока свойства `live`
инициализация экземпляров блока будет *отложена* до момента, когда
экземпляр блока потребуется в работе
([ленивая инициализация](#init-live)). Таким моментом может быть
DOM-событие на экземпляре блока, на которое выполнена делегированная
подписка, или обращение к экземпляру блока [из другого блока](#ibc).
Если инициализация блока не может быть отложена (требуется
[автоматическая инициализация](#init-auto)), следует вернуть `false` в
результате выполнения функции в значении свойства `live`.

-------------------------------------------------------------------------------

**NB:** Функция-обработчик выполняется в контексте ближайшего блока
  данного типа на пути распространения DOM-события (снизу вверх по
  DOM-дереву).

-------------------------------------------------------------------------------

**Удаление подписки** на делегированные DOM-события никогда не
  выполняется автоматически. Если подписку необходимо удалить, следует
  воспользоваться методом `liveUnbindFrom([elem], event, [handler])`.


### Объект DOM-события ###

В качестве параметра функции-обработчику передается jQuery-объект,
описывающий DOM-событие — [`{jQuery.Event}`](http://api.jquery.com/category/events/event-object/).

Если DOM-событие было сгенерировано вручную, все параметры, переданные
функции `trigger` при создании события, будут переданы
функции-обработчику в том же порядке после объекта события.



<a name="bem-events"></a>

## BEM-события ##

В отличие от DOM-событий, BEM-события генерируются не на
DOM-элементах, а на **экземплярах блоков**. Элементы блоков не могут
генерировать BEM-события.

Чтобы сгенерировать BEM-событие, используется метод экземпляра блока
`emit(event)`.

**Пример**: Взаимодействие пользователя с элементом управления блока
  (DOM-событие) можно преобразовать в BEM-событие на блоке. В
  приведенном ниже примере при клике пользователя по кнопке `submit`
  (DOM-событие `click`) **BEM-событие** `click` генерируется только в
  том случае, если у блока в этот момент не выставлен модификатор
  `disabled`:

```js
DOM.decl('submit', {
    onSetMod: {
        'js': {
            'inited': function() {
                this.bindTo('click', this._onClick); // подписка на DOM-событие "click"
            }
        }
    },

    _onClick: function() {
        if(!this.hasMod('disabled')) {
            this.emit('click'); // создание BEM-события "click"
        }
    }
});
```

Для подписки на BEM-события экземпляров блоков используются методы
экземпляра блока `on(event, [data], handler, [handlerCtx])`.

**Пример**: В момент инициализации HTML-формы (экземпляра блока `my-form`)
выполняется поиск вложенной в форму кнопки `submit` и подписка на
BEM-событие `click` этой кнопки. В результате при нажатии на кнопку
(экземпляр блока `submit`) будет выполнен метод `_onSubmit` формы
(экземпляр блока `my-form`).

```js
DOM.decl('my-form', {
    onSetMod: {
        'js': {
            'inited': function() {
                this.findBlockInside('submit').on(
                    'click', // имя BEM-события
                    this._onSubmit, // метод экземпляра блока my-form
                    this); // контекст для выполнения _onSubmit — блок my-form
            }
        }
    },

    _onSubmit: function() { /* ... */ }
});
```

-------------------------------------------------------------------------------

**NB:** Если не указывать последний параметр метода `on` —
  `[handlerCtx]`, контекстом для выполнения функции-обработчика будет
  тот блок, в котором возникло BEM-событие. (В примере выше — это блок
  `submit`.)

-------------------------------------------------------------------------------


**Удаление подписки** на BEM-события выполняется автоматически при
уничтожении экземпляра блока. Если требуется удалить подписку вручную
в процессе работы блока, следует использовать метод экземпляра блока
`un(event, [handler], [handlerCtx])`.


<a name="bem-events-delegated"></a>

### Делегирование BEM-событий ###

Делегирование BEM-событий означает, что блок подписывается на
определенное BEM-событие **всех экземпляров** блока с заданным именем
**в пределах заданного контекста**. Подписка на делегированные
BEM-события выполняется с помощью статического метода *класса блока*
`on([ctx], event, [data], handler, [handlerCtx])`.

Параметры:

* `{jQuery} [ctx]` — DOM-узел, в пределах которого отслеживаются
BEM-события (контейнер). Если не указан, в качестве контейнера
используется весь документ.
* `{String} event` — имя BEM-события.
* `{Object} [data]` — произвольные данные, передаваемые
  функции-обработчику.
* `{Function} handler` — функция-обработчик события.
* `{Object} [handlerCtx]` — контекст функции-обработчика
  события. Обычно в качестве контекста должен выступать тот экземпляр
  блока, который подписывается на BEM-событие, а не тот, в котором BEM-событие
  произошло.


**Пример**: При инициализации экземпляров блока `menu` выполняется
  подписка на BEM-событие `click` всех ссылок (экземпляров блока
  `link`) в пределах DOM-узла, к которому привязано меню
  (`this.domElem`). В качестве контекста функции-обработчика
  передается экземпляр блока, в котором событие будет обрабатываться
  (`this`). При [уничтожении экземпляров блока](#destruct) `menu`

```js
DOM.decl('menu', {
    onSetMod : {
        'js' : {
            'inited' : function() {
                DOM.blocks['link'].on( // подписка на BEM-событие
                    this.domElem, // контейнер — DOM-узел экземпляра блока menu
                    'click', // BEM-событие
                    this._onLinkClick, // обработчик
                    this); // контекст обработчика — экземпляр блока menu
            },

            '' : function() {
                DOM.blocks['link'].un( // удаление подписки на BEM-событие
                    this.domElem,
                    'click',
                    this._onLinkClick,
                    this);
            }
        }
    },

    _onLinkClick : function(e) {
        var clickedLink = e.target; // экземпляр блока 'link', на котором произошло BEM-событие 'click'
    }
});
```

-------------------------------------------------------------------------------

**NB:** Если не указывать параметр `[handlerCtx]` метода `on`,
  контекстом для функции-обработчика будет тот блок, в котором
  *возникло* BEM-событие.

-------------------------------------------------------------------------------

**Удаление подписки** на делегированные BEM-события никогда не
  происходит автоматически. Всегда следует явно удалять подписку при
  помощи статического метода блока `un([ctx], event, [handler],
  [handlerCtx])`.


Полное описание API для работы с BEM-событиями содержится в исходном
коде модулей [`i-bem`][] и [`i-bem__dom`][].


<a name="api"></a>

## Объект BEM-события ##

В качестве параметра функции-обработчику передается объект,
описывающий BEM-событие. Объект BEM-события `events.Event` определен
в [ymaps][]-модуле
[`events`](https://github.com/bem/bem-core/blob/v1/common.blocks/events/events.vanilla.js)
библиотеки bem-core. Содержит поля:

* `target` — экземпляр блока, в котором произошло BEM-событие.
* `data` — произвольные дополнительные данные. Передается в качестве
  параметра `data` в момент подписки на BEM-событие или при создании
  BEM-события блоком.
* `result` — последнее значение, возвращенное обработчиком данного
  события. аналогично [jQuery.Event.result](http://api.jquery.com/event.result/).
* `type` — тип события. Аналогично
[jQuery.Event.type](http://api.jquery.com/event.type/).

<a name="states"></a>

# Состояния блока #

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор **состояний** блока. Тогда
поведение блока определяется **триггерами** — callback-функциями, которые
выполняются при переходе блока из одного состояния в другое.

Такой подход позволяет писать код блока в декларативном стиле как
набор утверждений вида: «описание состояния — действия, выполняемые
при переходе в данное состояние».

<a name="modifiers"></a>

## Модификаторы ##

Согласно БЭМ-методологии, состояние блока и его элементов описывается
**модификаторами**.

Модификатор описывает, в каком из возможных состояний находится
блок. Модификатор представляет собой пару строк: **имя** и
**значение**. Список допустимых значений модификатора описывает
набор состояний блока. Например, для описания размеров блока можно
использовать модификатор `size` с допустимыми значениями `s`, `m` и
`l`.

**Простой модификатор** — частный случай, когда важно только наличие
или отсутствие данного модификатора у блока, а его значение
несущественно. Например, модификатор описывающий состояние «отключен»:
`disabled`. В *i-bem.js* представлены как модификаторы с булевым
значением. При выставлении модификатора с неуказанным значением
*i-bem.js* автоматически присваивает ему значение `true`.

Каждому блоку можно установить один или несколько модификаторов.  Блок
может не иметь модификаторов. Список допустимых модификаторов и их
значений определяет разработчик блока.

В *i-bem.js* модификаторы устанавливаются при
[инициализации экземпляра блока](#init) (если модификаторы и их
значения указаны в атрибуте `class` соответствующего HTML-элемента).

-------------------------------------------------------------------------------

**NB:** Если модификаторы блока указаны в HTML-элементе, при
  инициализации блока триггеры на установку данных модификаторов *не
  выполняются*. Экземпляр блока в этом случае получает начальное
  состояние, а не меняет его.

-------------------------------------------------------------------------------

Модификаторы могут добавляться, удаляться и менять значения:

* В ходе выполнения кода блока (например, в качестве реакции на [DOM-события](#dom-events)).
* По запросу из другого блока. Подробнее см. раздел [Взаимодействие блоков](#ibc).

При добавлении, удалении и изменении значений модификаторов выполняются триггеры.


<a name="mods-api"></a>

### Управление модификаторами ###

Экземпляр блока предоставляет методы для установки, проверки значений
и удаления модификаторов данного экземпляра.

-------------------------------------------------------------------------------

**NB:** Модификаторы нельзя устанавливать, напрямую меняя CSS-классы на
соответствующем DOM-узле. Для изменения значений модификаторов следует
использовать описанный ниже API, предоставляемый *i-bem.js*.

-------------------------------------------------------------------------------

**Пример**: Экземпляр блока `square` может по клику на DOM-элементе
блока переключаться между значениями `green` и `red` модификатора
`color`, если не выставлен модификатор `disabled`:

```js
DOM.decl('square', {
    onSquareClick: function(e) {
        if(!this.hasMod('disabled')) {
            this.toggleMod('color', 'green', 'red');
        }
    }
});
```

Эти же методы используются для управления модификаторами элементов
блока. Для этого в качестве первого (необязательного) параметра
указывается ссылка на объект элемента (а не имя элемента).

**Пример**: Блок `searchbox` по клику может выставлять своему элементу
`input` простой модификатор `clean` (подразумеваемое значение —
`true`):

```js
DOM.decl('searchbox', {
    _onClick: function() {
        this.setMod(this.elem('input'), 'clean');
    }
});
```

-------------------------------------------------------------------------------

**NB:** При управлении модификаторами элементов в качестве первого
  параметра необходимо указывать ссылку на **DOM-узел элемента**, а не
  имя элемента. В противном случае возникла бы неоднозначность:
  имеется в виду установка блоку *модификатора* `input` со значением
  `clean` или установка элементу `input` *простого модификатора* `clean`.

-------------------------------------------------------------------------------

Полное описание API для управления модификаторами приведено в
исходном коде модулей [`i-bem`][] и [`i-bem__dom`][].


## Триггеры на установку модификаторов ##

Выполнение триггеров на установку модификаторов разбито на две фазы:

1. **До установки модификатора**. Эта фаза зарезервирована для
   возможности **отменить** установку модификатора. Если хотя бы один
   из триггеров, выполняемых в этой фазе, вернет `false`, установки
   модификатора не произойдет.
2. **После установки модификатора**. Триггеры, выполняемые в этой
   фазе, уже не могут отменить установку модификаторов.


Триггеры могут быть привязаны к следующим типам изменений значений модификаторов:

1. установка *любого* модификатора в *любое* значение;
2. установка *конкретного* модификатора `modName` в *любое* значение (в том числе
   установка простого модификатора в значение `true`);
3. установка *конкретного* модификатора `modName` в *конкретное* значение `modVal`;
4. установка модификатора в значение `''` (пустая строка), что
   эквивалентно удалению модификатора или установке простого
   модификатора в значение `false`).


При установке модификатора `modName` в значение `modVal` триггеры
каждой фазы (если они определены) вызываются в том порядке, в котором они
перечислены в приведенном выше списке событий (от общего к частному).

Таким образом, при определении триггера пользователь указывает:

* фазу выполнения (до или после установки модификатора);
* тип события (имя и устанавливаемое значение модификатора).

### Декларация триггеров ###

Триггеры, выполняемые при установке модификаторов, описываются в
декларации блока. Для этого в хэше методов экземпляра блока
зарезервированы свойства:

* `beforeSetMod` — триггеры, вызываемые до установки
  **модификаторов блока**.
* `beforeElemSetMod` — триггеры, вызываемые до установки
  **модификаторов элементов**.
* `onSetMod` — триггеры, вызываемые после установки
  **модификаторов блока**.
* `onElemSetMod` — триггеры, вызываемые после установки
  **модификаторов элементов** блока.

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl(/* селектор блока */,
    {
        /* методы экземпляра */
        beforeSetMod: { /* триггеры до установки модификаторов блока*/}
        beforeElemSetMod: { /* триггеры до установки модификаторов элементов*/}
        onSetMod: { /* триггеры после установки модификаторов блока */ }
        onElemSetMod: { /* триггеры после установки модификаторов элементов */ }
    },
    {
        /* статические методы */
    }
);

provide(DOM);

});
```

Значение свойств `beforeSetMod` и `onSetMod` — хэш, связывающий
изменения модификаторов с триггерами. В качестве параметров триггерам
передаются:

* имя модификатора;
* выставляемое значение модификатора;
* предшествующее (для `beforeElemSetMod`) или текущее (для `onElemSetMod`) значение модификатора.

```js
{
    'mod1': function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
    'mod2': {
        'val1': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
        'val2': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
        '': function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
    'mod3': {
        'true': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
        '': function(modName, modVal, prevModVal) { /* ... */ }, // триггер на удаление простого модификатора mod3
    },
    '*': function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
}
```

Для триггера на установку любого модификатора блока в любое значение
существует сокращенная форма записи:

```js
beforeSetMod: function(modName, modVal, prevModVal) { /* ... */ }
onSetMod: function(modName, modVal, prevModVal) { /* ... */ }
```

Для свойств `beforeElemSetMod` и `onElemSetMod` в хэш значений
добавляется дополнительный уровень вложенности — **элемент**. В этих
свойствах описываются триггеры на установку модификаторов элементов.
В качестве параметров триггеру передаются:

* имя элемента;
* имя модификатора;
* выставляемое значение модификатора;
* предшествующее (для `beforeElemSetMod`) или текущее (для `onElemSetMod`) значение модификатора.


```js
{
    'elem1': {
        'mod1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod1 элемента elem 1 в любое значение
        'mod2': {
            'val1': function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 элемента elem1 в значение val1
            'val2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку mod2 элемента elem1 в значение val2
            }
        },
    'elem2': function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора элемента elem2 в любое значение
}
```

Сокращенная запись для триггера на установку любого модификатора элемента
`elem1` в любое значение:

```js
beforeElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
onElemSetMod: { 'elem1': function(elem, modName, modVal, prevModVal) { /* ... */ } }
```

### Примеры триггеров ###

Типовая задача триггеров, вызываемых после установки модификатора или
изменения его значения (свойство `onSetMod`) — выполнить операции над
DOM-узлом блока, необходимые для перехода в новое состояние.

**Пример**: Экземпляр блока `input` при установке простого
  модификатора `focused` (в значение `true`) очищает поле ввода —
  заменяет пустой строкой текст DOM-узла блока.

```js
DOM.decl('input', {
    onSetMod : {
        'focused' : {
            'true' : function() {
                this.domElem.val(''); // очистить поле ввода
            }
        }
    }
});
```

Триггеры, выполняемые перед установкой модификатора (свойство
`beforeSetMod`), необходимы для проверки текущего состояния экземпляра
блока и возможности отменить переход в другое состояние.

**Пример**: Экземпляр блока `input` перед установкой простого
  модификатора `focused` проверяет, не выставлен ли у него модификатор
  `disabled`. Если `disabled` выставлен, будет возвращено значение `false` и
  установки модификатора `focused` не произойдет.

```js
DOM.decl('input', {
    beforeSetMod : {
        'focused' : {
            'true' : function() {
                return !this.hasMod('disabled'); // вернет false, если disabled
            }
        }
    }
});
```


<a name="init"></a>

## Инициализация ##

Инициализация блока — это создание в памяти браузера JS-объекта,
соответствующего экземпляру блока. Инициализация экземпляров блоков выполняется
методом `init()` модуля `i-bem__dom` на заданном фрагменте DOM-дерева.

Каждому экземпляру блока можно приписать три состояния:

* экземпляр блока не инициализирован (JS-объект не создан);
* экземпляр блока инициализирован (JS-объект создан в памяти браузера);
* экземпляр блока уничтожен (удалены все ссылки на JS-объект экземпляра
  блока и он может быть удален сборщиком мусора).

В *i-bem.js* эти состояния экземпляра блока описываются с помощью служебного
модификатора `js`.

* До инициализации экземпляр блока не имеет модификатора `js`.

```html
<div class="my-block i-bem" data-bem="..." >...</div>
```

* В момент инициализации экземпляру блока устанавливается модификатор
  `js` в значении `inited`.

```html
<div class="my-block i-bem my-block_js_inited" data-bem="...">...</div>
```

* Если в процессе работы удаляется фрагмент DOM-дерева (при помощи
  метода `destruct` модуля `i-bem__dom`) , то вместе с
  ним удаляются экземпляры блоков, все HTML-элементы которых находятся
  в этом фрагменте. Перед удалением экземпляра блока модификатор `js`
  удаляется.

-------------------------------------------------------------------------------

**NB:** Если экземпляр блока был
  [привязан к нескольким HTML-элементам](#distrib-block), блок будет существовать,
  пока в HTML-дереве сохраняется хотя бы один элемент, с которым он
  связан.

-------------------------------------------------------------------------------


Если на HTML-элементе размещено несколько экземпляров других блоков, то
инициализация одного из них (появление модификатора `my-block_js_inited`)
не влияет на инициализацию остальных.

**Пример**: На HTML-элементе инициализирован только экземпляр блока `my-block`,
экземпляр блока `lazy-block` не инициализирован:

```html
<div class="my-block my-block_js_inited lazy-block i-bem"
    data-bem='{ "my-block": {}, "lazy-block": {} }' >
    ...
</div>
```

-------------------------------------------------------------------------------

**NB:** Наличие модификатора `js` позволяет писать разные CSS-стили для
  блока в зависимости от того, инициализирован он или нет.

-------------------------------------------------------------------------------


### Конструктор экземпляра блока ###

На изменение значений модификатора `js` можно назначать триггеры так
же, как и для любых других модификаторов блока.

Триггер на установку модификатора `js` в значение `inited` выполняется
при создании блока. Этот триггер можно считать **конструктором
экземпляра блока**:

```js
onSetMod: {
    'js': {
        'inited': function() { /* ... */ } // конструктор экземпляра блока
    }
}
```


<a name="destruct"></a>

### Деструктор экземпляра блока ###

Моментом удаления блока является момент уничтожения всех ссылок на
JS-объект блока, после чего он может быть удален из памяти браузера
сборщиком мусора.

Триггер на удаление модификатора `js` (установку в пустое значение
`''`) выполняется перед удалением блока. Такой триггер можно считать
**деструктором экземпляра блока**.

```js
onSetMod: {
    'js': {
        '': function() { /* ... */ } // деструктор экземпляра блока
    }
}
```


<a name="init-wave"></a>

### Волны инициализации ###

Инициализация экземпляров блоков, присутствующих на странице, не
обязательно происходит одновременно. Блоки могут добавляться в ходе
работы (например, за счет динамической генерации HTML на основе
данных, полученных от сервера) или инициализироваться только по запросу.
Инициализация очередной группы блоков называется **волной
инициализации**.

Новая волна инициализации создается в следующих случаях:

* [Автоматическая инициализация всех блоков в документе по событию `domReady`](#init-auto);
* [Инициализация блока по событию на DOM-узле](#init-live) (ленивая инициализация);
* [Явный вызов инициализации блоков на указанном фрагменте DOM-дерева](#init-ajax).


<a name="init-auto"></a>

### Автоматическая инициализация ###

Фреймворк *i-bem.js* позволяет автоматически инициализировать все
блоки, имеющие DOM-представление (привязанные к DOM-элементам на
странице) в момент наступления DOM-события `domReady`. Чтобы включить
автоматическую инициализацию, необходимо задекларировать на странице
блок `i-bem` с модификатором `init` в значении `auto`. Пример файла
`.deps.js`:

```js
({
    shouldDeps: [
        {
            block: 'i-bem',
            elem: 'dom',
            mods: { 'init': 'auto' }
        }
    ]
})
```

При автоматической инициализации в памяти браузера будут созданы
JS-объекты для всех DOM-узлов, в атрибуте `class` которых указан
`i-bem`. Инициализация выполняется функцией `init` модуля
[`i-bem__dom`][].

<a name="init-live"></a>

### Инициализация по событию (ленивая инициализация) ###

Если на странице размещено много экземпляров блоков, автоматическая инициализация
всех блоков в момент загрузки страницы нежелательна, так как она
увеличивает время загрузки и объем памяти, затрачиваемой браузером.

В этом случае имеет смысл инициализировать JS-объекты
только в тот момент, когда их функциональность потребуется
пользователю, например, по клику на блоке. Такая инициализация
называется **ленивой** или **live-инициализацией**.

Для описания условий ленивой инициализации зарезервировано свойство
`live` в разделе статических методов декларации блока. Свойство `live`
может принимать два типа значений:

* `Boolean`.<br/> Имеет смысл только значение `true`: экземпляры
  блоков данного класса будут инициализированы только при попытке
  получить соответствующий экземпляр. Подробнее
  см. раздел [Взаимодействие блоков](#ibc).

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('my-block',
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // этот код будет выполняться
                                                   // при первом обращении к экземпляру блока
            }
        }
    },
    { live: 'true' } // статические методы и свойства
);

provide(DOM);

});
```

* `Function`.<br/> Функция, которую нужно выполнить при попытке
    инициализации **первого экземпляра** блока заданного класса.  Если
    функция возвращает значение `false`, экземпляры блоков будут
    инициализироваться [автоматически](#init-auto).

Если необходимо инициализировать экземпляры блока по наступлению
DOM- или BEM-событий, в теле функции следует выполнить подписку на
[делегированные события](#delegated-events). Возможна инициализация
по:

* DOM-событию на DOM-узле блока и вложенных элементах;
* BEM-событию на вложенных блоках.


**Пример**: Экземпляры блока `my-block` будут инициализироваться по
  DOM-событию `click` на DOM-узле блока. По каждому DOM-событию
  `click` будет вызываться метод экземпляра блока `_onClick`:

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('my-block',
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // выполняется при первом DOM-событии 'click'
            }
        },

        _onClick: function() { /* ... */ } // выполняется при каждом DOM-событии 'click'
    },
    {
        live: function() {
            this.liveBindTo('click', function() {
                this._onClick(); // в момент клика будет создан экземпляр блока и вызван его метод _onClick
            });
        }
    }
);

provide(DOM);

});
```

Если необходимо воспользоваться делегированными событиями в блоке, но
инициализацию блока нельзя отложить (экземпляры блока должны быть
инициализированы немедленно после загрузки страницы), следует вернуть
значение `false`:


```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('my-block',
    {
        onSetMod: {
            'js': {
                'inited': function() { /* ... */ } // будет выполнена по наступлении domReady
            }
        },

        _onClick: function() { /* ... */ } // будет выполняться каждый
                                           // раз при наступлении DOM-события 'click'
    },
    {
        live: function() {
            this.liveBindTo('click', function() { this._onClick() });
            return false; // экземпляры блоков будут инициализированы автоматически
        }
    }
);

provide(DOM);

});
```

Полный список хелперов для подписки на делегированные события
приведен в исходном коде модуля [`i-bem__dom`][].

-------------------------------------------------------------------------------

**NB:** Свойство `live` задает ленивую инициализацию для *всех
  экземпляров* соответствующего блока, так как технически относится к
  статическим методам класса блока. Поэтому даже если свойство `live`
  задекларировано для блока с определенным значением модификатора, оно
  будет применено ко всем блокам данного класса вне зависимости от
  модификаторов.

-------------------------------------------------------------------------------


<a name="init-ajax"></a>

### Инициализация и удаление блоков на фрагменте DOM-дерева ###

Процедура инициализации или уничтожения JS-объектов может быть вызвана
явно для указанного фрагмента DOM-дерева. Часто такая необходимость
возникает при разработке AJAX-интерфейсов, когда нужно [динамически
встроить в страницу новые экземпляры блоков](#dynamic) либо обновить существующие.

В *i-bem.js* следующие функции выполняют динамическую инициализацию блоков:

* Инициализация/уничтожение блоков на указанном фрагменте DOM-дерева
  (`init`, `destruct`);
* Добавление/замена фрагмента DOM-дерева с одновременной
  инициализацией блоков на обновленном фрагменте (`update`, `replace`,
  `append`, `prepend`, `before`, `after`).


<a name="init-bem"></a>

### Инициализация и удаление блоков без DOM-представления ###

Чтобы создать JS-объект для блока, не имеющего DOM-представления (не
привязанного к HTML-элементу), необходимо вызвать метод `create`,
который вернет экземпляр блока указанного класса.

**Пример**: В момент инициализации экземпляра блока с DOM-представлением
  `container` создается экземпляр блока без DOM-представления `router`. Экземпляр блока
  `container` затем будет обращаться к созданному им экземпляру блока
  `router` при вызове метода `onRequest`:

```js
modules.define('i-bem__dom', 'i-bem', function(provide, BEM, DOM) {

DOM.decl('container', {
    onSetMod: {
        'js': {
            'inited': function() {
                this._router = BEM.create('router'); // создание экземпляра блока router
            }
        }
    },

    onRequest: function() {
        this._router.route(/* ... */) // вызов метода экземпляра блока router
    }
});

provide(DOM);

});
```

**Пример**: Блок без DOM-представления реализован в виде простого
  [ymaps-модуля][ymaps], без использования модуля `i-bem`. Такой блок
  используется как обычный ymaps-модуль (нет необходимости создавать
  экземпляр блока):

```js
modules.define('i-bem__dom', 'router', function(provide, DOM, router) {

DOM.decl('container', {
    onRequest: function() {
        router.route(/* ... */); // вызов метода блока router
    }
});

provide(DOM, router);

});
```

**Удаление** экземпляров блоков без DOM-представления не может быть
выполнено автоматически и является ответственностью
разработчика. Блоки без DOM-представления представляют собой обычные
JS-объекты и удаляются в момент удаления всех ссылок на объект блока.


**Пример**: При удалении экземпляра блока `container` удаляется созданный им в
процессе работы экземпляр блока без DOM-представления `router`.

```js
modules.define('i-bem__dom', 'i-bem', function(provide, BEM, DOM) {

DOM.decl('container', {
    onSetMod : {
        'js' : {
            '' : function() {
                delete this._router; // удаление экземпляра блока router
            }
        }
    }
});

provide(DOM);

});
```


<a name="ibc"></a>

# Взаимодействие блоков #

В рамках БЭМ-методологии блоки следует разрабатывать так,
чтобы по возможности исключить зависимость состояний одних
блоков от других. Однако на практике идеал полной независимости блоков
недостижим.

Взаимодействие блоков может быть реализовано двумя способами:

* С помощью подписки на [BEM-события](#bem-events) других экземпляров
  блоков или подписки на [делегированные BEM-события](#bem-events-delegated).
* С помощью непосредственного вызова методов других экземпляров
  блоков или статических методов класса другого блока.

-------------------------------------------------------------------------------

**NB:** Не используйте [DOM-события](#dom-events) для
  организации взаимодействия между блоками. DOM-события предназначены
  только для реализации внутренних процедур блока.

-------------------------------------------------------------------------------

Для реализации взаимодействия блоков *i-bem.js* предоставляет API:

* [Поиск экземпляров блоков в DOM-дереве](#api-find);
* [Доступ к экземплярам блоков без DOM-представления](#api-nodom);
* [Доступ к классам блоков](#api-calss).


<a name="api-find"></a>

## Поиск экземпляров блоков в DOM-дереве ##

Обращение к другому блоку в *i-bem.js* выполняется из текущего блока,
размещенного на определенном узле DOM-дерева. Поиск других блоков в
DOM-дереве может вестись по трем направлениям (осям) относительно
DOM-узла текущего блока:

* «Внутри блока» — на DOM-узлах, вложенных в DOM-узел текущего блока.
* «Снаружи блока» — на DOM-узлах, потомком которых является DOM-узел
  текущего блока. Необходимость в таком поиске может свидетельствовать
  о неудачной архитектуре интерфейса.
* «На себе» — на том же DOM-узле, на котором размещен текущий
  блок. Это актуально в случае [размещения нескольких JS-блоков на
  одном DOM-узле](#html-mixes) (микс).

**Пример**: При переключении модификатора `disabled` экземпляр блока
  `attach` находит вложенный в него блок `button` и переключает его
  модификатор `disabled` в то же значение, которое получил сам:

```js
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl('attach', {
    onSetMod: {
        'disabled': function(modName, modVal) {
            this.findBlockInside('button').setMod(modName, modVal);
        }
    }
});

provide(DOM);

});
```

Полный список методов для поиска блоков блоков приведен
в исходном коде модуля [`i-bem__dom`][].


-------------------------------------------------------------------------------

**NB:** Не используйте jQuery-селекторы для поиска блоков и элементов.
*i-bem.js* предоставляет высокоуровневое API для доступа к DOM-узлам
блоков и элементов. Обращение к DOM-дереву в обход этого API делает
код менее устойчивым к изменениям БЭМ-библиотек и может привести к
возникновению сложно обнаруживаемых ошибок.

-------------------------------------------------------------------------------

<a name="api-nodom"></a>

## Доступ к экземплярам блоков без DOM-представления ##

При создании экземпляра блока без DOM-представления необходимо
позаботиться о том, чтобы ссылка на этот экземпляр была доступна
блокам, которым потребуется взаимодействовать с ним. Подробности и
пример см. в разделе [Инициализация и удаление блоков без DOM-представления](#init-bem).

<a name="api-class"></a>

## Доступ к классам блоков ##

JS-компоненты, соответствующие всем блокам («классы» блоков), хранятся
в структуре данных `BEM.blocks`. Классы блоков,
[не привязанных к DOM-дереву](#i-blocks), также размещены в этой
структуре данных. При необходимости доступа к таким блокам следует
использовать конструкцию:
```js
BEM.blocks['name']
```
где `name` — имя блока.

Доступ к классам блоков необходим для решения двух основных задач:

* [Делегирование БЭМ-событий](#bem-events-delegated).
* Вызов статического метода класса.

**Пример**: Вызов статического метода `close` блока `popup` — закрыть
  все попапы на странице:

```js
DOM.decl('switcher', {
    onSetMod : {
        'popup' : {
            'disabled' : function() {
                BEM.blocks['popup'].close();
            }
        }
    }
});
```

<a name="docs"></a>

# Что дальше? #

Общую информацию о БЭМ-методологии, инструментарии, новостях в мире
БЭМ можно найти на сайте [bem.info](http://ru.bem.info/).

Полную информацию обо всех методах API *i-bem.js* можно найти в
исходном коде, который сопровождается структурированными комментариями
в формате JSDoc:

* [`i-bem`][];
* [`i-bem__dom`][].

Задать вопрос опытным пользователям и разработчикам *i-bem.js* и
следить за текущими обсуждениями можно в социальных сетях:

* [Клуб в Я.ру](http://clubs.ya.ru/bem/);
* [Группа в Facebook](http://www.facebook.com/#!/groups/209713935765634/);
* [Twitter](https://twitter.com/bem_ru).

Прочитать о принципах работы *i-bem.js* в другом изложении, найти
образцы его применения и пошаговые инструкции на примере простых
проектов можно в статьях:

* [JavaScript по БЭМ: основные понятия](http://ru.bem.info/articles/bem-js-main-terms/);
* [Tutorial on JavaScript in BEM terms](https://github.com/varya/bem-js-tutorial);
* [Попробуй БЭМ на вкус!](http://habrahabr.ru/post/162385/);
* [БЭМ-приложение на Leaflet и API 2GIS](http://ru.bem.info/articles/firm-card-story/).


-------------------------------------------------------------------------------

**NB:** Обратите внимание, что в перечисленных статьях может
использоваться устаревший синтаксис, не соответствующий текущей версии
*i-bem.js*, включенной в bem-core.

-------------------------------------------------------------------------------


[ymaps]: https://github.com/ymaps/modules

[bem-tools]: http://ru.bem.info/tools/bem/

[`i-bem`]: https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.vanilla.js

[`i-bem__dom`]: https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js
