<!--# i-bem.js: Руководство пользователя-->

# Общие сведения #

## i-bem.js: Клиентский Javascript-фреймворк для БЭМ ##

i-bem.js — специализированный JavaScript-фреймворк для веб-разработки в рамках [БЭМ-методологии](http://ru.bem.info/method/). 
С помощью i-bem.js можно:

 * разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
 * описывать логику работы блока в декларативном стиле — как набор состояний;
 * легко интегрировать JavaScript-код с CSS в стиле БЭМ и BEMHTML-шаблонами;
 * гибко переопределять поведение библиотечных блоков.

i-bem.js не может:

 * работать с состоянием на сервере (только клиентский JavaScript);
 * заменить высокоуровневые фреймворки общего назначения, подобные jQuery.

## БЭМ-методология и JavaScript ##

С точки зрения БЭМ-методологии веб-интерфейс строится из независимых **блоков** (внутри которых могут 
быть выделены **элементы**). И блоки, и элементы могут иметь состояния, описываемые **модификаторами**.

Работа веб-интерфейса обеспечивается несколькими **технологиями** (HTML, CSS, JS...), 
и описание блока складывается из реализаций в этих технологиях. Обычно реализация разбита на несколько файлов, например:

 * `block.css` — описывает внешний вид блока;
 * `block.bemhtml` — шаблоны для генерации HTML-представления блока;
 * `block.js` — описывает **поведение** блока.

Фреймворк i-bem.js позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:

 + **Блок** — JS-компонент, описывающий логику работы однотипных элементов интерфейса. Например, все кнопки могут быть реализованы
 с использованием блока `button`. Тогда, в соответствии с БЭМ-методологией, `button.css` определяет внешний вид всех кнопок, 
 а `button.js` — их логику работы.  
 + На каждой странице может размещаться более одного **экземпляра** блока. Каждому экземпляру блока соответствует JS-объект, 
 динамически создаваемый в памяти браузера и хранящий состояние данного экземпляра блока.
 + **Элементы** — Особые поля в структуре данных экземпляра блока.  
 + **Модификаторы** — Особые поля экземпляра блока, хранящие информацию о состоянии блока и его элементов.



## Как использовать i-bem.js ##

Фреймворк i-bem.js входит в состав библиотеки [bem-core](http://github.com/bem/bem-core/).

Можно использовать i-bem.js как часть полного стека БЭМ-инструментов. Свой проект удобно создавать 
на основе шаблонного репозитория [project-stub](http://github.com/bem/project-stub/), в котором 
подключены все необходимые библиотеки и настроена установка БЭМ-инструментов. 

Если не планируется использование других технологий БЭМ-платформы, можно
подключить библиотеку bem-core в существующий проект любым доступным способом.

Исходный код i-bem.js — JS-реализация блока [i-bem](http://github.com/bem/bem-core/tree/v1/common.blocks/i-bem/).
Существенные компоненты реализации: 

 * Прототип описания блока `i-bem.vanilla.js`
 * Реализация элемента [i-bem__dom](https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/\_\_dom/i-bem\_\_dom.js).
 * Внутренние хелперы `i-bem__internal.vanilla.js`

Зависимости: 

 * jQuery. При использовании bem-core отдельная установка jQuery не требуется.
 * Модульная система [ymaps/modules](https://github.com/ymaps/modules). 
 * ymaps-модули `inherit`, `next-tick`, `vow` из библиотеки bem-core.

## Сборка ##

Разработка в рамках БЭМ-методологии ведется модульно: каждый блок программируется отдельно, финальный исходный
код веб-страниц формируется из описаний блоков с помощью процедур **сборки**.

В файловой системе блок удобно представлять в виде каталога, а реализацию блока 
в каждой из технологий — в виде отдельного файла:

    desktop.blocks/
        myblock/
            myblock.css
            myblock.js
            myblock.bemhtml
            ...

    desktop.blocks/
        otherblock/
            otherblock.css
            otherblock.js
            otherblock.bemhtml
            ...

Для каждой веб-страницы код использованных на ней блоков должен быть собран в единые файлы: 

    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...

Автоматизацию сборки кода результирующих веб-страниц из отдельных описаний блоков осуществляют
инструменты пакета [bem-tools](http://github.com/bem/bem-tools/). 

*?? Можно ли пользоваться i-bem.js, не используя bem-tools?*

## Почему i-bem.js так называется ##

В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и 
гибко переопределять поведение библиотеки на разных уровнях переопределения.

Служебным блокам в БЭМ принято давать имена с префиксом `i-`. Таким образом, имя `i-bem.js` 
читается как «реализация блока `i-bem` в технологии `js`».


# Привязка блоков к HTML #

JavaScript-компоненты в i-bem.js служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — привязать обработку определенных событий к
указанному HTML-фрагменту. 

 * Первичным является DOM-дерево документа, в котором размечены блоки, элементы и модификаторы (в атрибутах `class` HTML-элементов). 
 * Таким образом, в DOM-дереве каждому экземпляру блока соответствует DOM-элемент.
 * Если блок имеет JavaScript-реализацию, к каждому упоминанию блока на странице (DOM-элементу) должен быть привязан JS-объект — экземпляр блока.
 * JS-объект, привязанный к DOM-элементу, обрабатывает происходящие на нем события и хранит состояние данного экземпляра блока.

Преимущества этого подхода к связи HTML и JavaScript-компонент: 

 * естественная деградация интерфейса на клиентах с отключенным JavaScript;
 * _прогрессивный рендеринг_ — возможность начать отрисовку элементов интерфейса до окончания загрузки всех данных страницы (например, изображений).


## Синтаксис привязки блоков ##

Чтобы привязать блок к HTML-элементу, необходимо: 

 1. **Отметить блок в DOM-дереве**.<br/>
 Включить имя блока в список классов HTML-элемента (атрибут `class`).
 2. **Инициализировать экземпляр блока**.<br/> 
 Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.
 3. **Передать параметры экземпляру блока**.<br/>
 Поместить параметры блока в атрибут `onclick`. Параметры блока представляют собой JS-хэш структуры __имя блока—хэш параметров__. 
 Параметры передаются экземпляру блока в момент инициализации.

Соотношение блоков и DOM-элементов не обязательно должно быть
одно-однозначным. Возможны следующие типы связи: 
 
### Один DOM-элемент — один JS-блок ###

Самый простой и распространенный способ привязки блоков к HTML.

Пример: HTML-элемент `div`, на котором размещен блок `myblock`, параметры блока — пустой список `{}`.

    <div class="myblock i-bem"
        onclick="return { 
            myblock: {},
        }">
        <span class="myblock__item"></span>
     </div>


### Один DOM-элемент — несколько JS-блоков ###

Техника размещения нескольких блоков на одном DOM-элементе в БЭМ-методологии называется **микс**. 

Пример: HTML-элемент `div`, на котором размещены блоки `myblock` и `anotherblock`, параметры обоих блоков — пустой список `{}`.

    <div class="myblock anotherblock i-bem"
        onclick="return { 
            myblock: {},
            anotherblock: {}
        }">
        <span class="myblock__item"></span>
     </div>


### Один JS-блок на нескольких DOM-элементах ###

Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из нескольких компонент, 
сосотяние которых должно быть согласовано. Например, виджет «вкладки», где клик по заголовку 
вкладки (один HTML-элемент), меняет содержимое вкладки (другой HTML-элемент). Другой пример —
маркер, обозначающий точку на карте (первый элемент) и связанное с ним описание точки в списке рядом с картой (второй элемент).

Чтобы привязать блок к нескольким DOM-элементам, нужно в параметрах блока на обоих HTML-элементах
указать одинаковое значение `id`.

Пример: Блок `notebook` привязан к HTML-элементам `div` и `span`, в параметрах блока указан общий `id` — `notebook`.

    <div class="notebook i-bem"
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </div>

    ...
    
    <span class="notebook i-bem" >
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </span>


В результате при инциализации блоков будет создан один JS-объект, содержащий ссылки на оба DOM-узла. 
_!!уточнить, верно ли!!_


### JS-блок не привязан к DOM-элементу ###

Инфраструктурный код, решающий общие задачи интерфейса: связь с бэкэндом, общие вычисления и т.п. — при работе с i-bem.js 
можно оформлять в виде блока, как и весь прочий JS-код. Чтобы не привязывать такие блоки к DOM-дереву икусственно, 
i-bem.js предоставляет возможность создавать блоки без DOM-представления. 

Блоки без DOM-представления:

 * В HTML-коде страницы не указываются.
 * JS-код блока (декларация) пишется с использованием несколько иного синтаксиса, чем для блоков с DOM-представлением. Подробнее см. FIXME. 

**NB**: В общем случае инфраструктурный код следует оформлять не в виде блока без DOM-представления, а в виде ymaps-модуля. Например: 

    modules.define('router', function(provide) {

    provide({
        route : function() { ... }
    });

    });



## Синтаксис передачи параметров ##

Параметры блока — произвольный JavaScript-объект, который будет передан блоку в момент инициализации. 
Параметры позволяют модифицировать поведение экземпляра блока, привязанного к данному DOM-узлу.

В значении атрибута `onclick` указываются параметры _всех JS\_блоков, размещенных на данном узле_. 
Параметры передаются с помощью конструкции `return` в виде хэша:

 + ключ — имя блока;
 + значение — хэш параметров данного блока. Если данному экземпляру блока не требуются 
   параметры, указывается пустой хэш `{}`.

Такой формат параметров продиктован следующими соображениями:

 * Указание имени блока в параметрах позволяет избежать необходимости парсить значение атрибута `class`,
   что упрощает и ускоряет инициализацию блоков. Это же решение позволяет размещать несколько блоков на одном 
   DOM-узле без необходимости множить атрибуты элемента.
 * Передача параметров в виде нативного JS-объекта позволяет обходиться для этой цели одним HTML-атрибутом
   и передавать в качестве параметров произвольный JS-код.

*NB: на некоторых уровнях переопределения для передачи блока может использоваться другой HTML-атрибут. Например, в 
библиотеке bem-bl для блоков сенсорных интерфейсов используется атрибут `ondblclick`.*

# Декларация блока #

JS-реализация блока описывает функциональность определенного класса элементов веб-интерфейса. В конкретных 
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует 
функциональность всего класса и имеет собственное состояние, независимое от остальных.

В терминах парадигмы объектно-ориентированного программирования: 

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в _методах_ класса (= блока). 
Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в i-bem.js принято называть **декларацией**, чтобы подчеркнуть принятый в БЭМ декларативный
стиль программирования. В соответствии с декларативным стилем поведение блока программируется как 
утверждения вида _набор условий — реакция блока_.

	
## Синтаксис декларации ##

Чтобы декларировать новый JS-блок, необходимо переопределить ymaps-модуль `i-bem__dom`. 

Блоки, имеющие DOM-представление (привязанные к DOM-элементу) декларируются с помощью 
метода `DOM.decl`, принимающим три параметра: 

1. Селектор блока — строка (имя блока) или хэш (описание блока). Подробнее см. FIXME
2. Методы экземпляра блока — хэш.
3. Статические методы — хэш.

        modules.define('i-bem__dom', function(provide, DOM) {
        
        DOM.decl(/* селектор блока \*/,
            { 
                /* методы экземпляра \*/
            },
            {
                /* статические методы \*/
            }
        );
        
        provide(DOM);
        });

Блоки, не имеющие DOM-представления, декларируются как переопределение ymaps-модуля `i-bem`. 
Вместо метода `DOM.decl` используется метод `BEM.decl`, принимающий те же параметры: 

    modules.define('i-bem', function(provide, BEM) {

    BEM.decl(/* селектор блока \*/,
        { 
            /* методы экземпляра \*/
        },
        {
            /* статические методы \*/
        }
    );
    
    provide(BEM);
    });


## Селектор блока ##

Селектор представляет собой описание блока, в котором будут применяться
объявленные в декларации методы.  Селектор обязательно содержит имя блока и 
может содержать условия, ограничивающие сферу действия методов определенной
модификацией блока или наличием других блоков на том же DOM-узле.

Селектор может быть задан в одной из двух форм:

1. Имя блока — строка. 
   Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).
Пример: декларация методов для блока `button`.

        DOM.decl('button',
            { 
                /* методы экземпляра \*/
            },
            {
                /* статические методы \*/
            }
        )

2. Описание блока — хэш.
   В описании зарезервированы следующие ключи:

   * `block` (строка) — имя блока, обязательный параметр.

   * `baseBlock` (строка) — Имя родительского блока (класса). Данный
     блок наследует все методы родительского блока.

   * `baseMix` (массив) — Имена дополнительных родительских блоков,
     позволяет реализовать множественное наследование. Данный блок
     наследует методы всех указанных родительских блоков.

   * `modName` (строка) — Имя модификатора блока. Объявленные методы
     будут привязаны только к экземплярам блока с указанными
     значениями модификатора. Если не указан параметр `modVal`,
     селектор применяется к блокам с указанным модификатором
     независимо от его значения.

   * `modVal` (строка/массив) — Значение или массив значений
     модификатора блока.  Объявленные методы будут привязаны только к
     экземплярам блока с указанными значениями
     модификатора. Предполагает указание параметра `modName`.

Примеры:

Декларация методов для блока `button` с модификатором `pseudo` в значении `yes` (описывает поведение псевдокнопок):

    DOM.decl({ block: 'button', modName: 'pseudo', modVal: 'yes' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )

Блок `checkbutton` наследует блокам `button` и `checkbox`:

    DOM.decl({ block: 'checkbutton', baseBlock: 'button', baseMix: 'checkbox' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )
 


## Контекст ##

В коде блока контекстом всегда является JS-объект экземпляра блока, а
не DOM-элемент, на котором размещен блок. Ссылка на экземпляр блока
(контекст) доступна в коде блока посредством ключевого слова `this`.

**NB**: Для обращения к DOM-элементу блока используется общий метод
  блоков `getElem`. Подробнее см. FIXME.

Контекст содержит зарезервированные поля:

 + `this.__self`: Ссылается на статические методы класса, к которому принадлжит экземпляр.

Пример: Вызов статического метода в методе экземпляра блока.

    DOM.decl('myblock', {
        method: function() {
            this.__self.staticMethod();
            this.doMore();
        }, 
        {}
    });


 + `this.__base`: Ссылается на реализацию метода в базовом классе, которому наследует данный.
    Позволяет выполнить super call. 

Пример: вызов (и модификация) метода родительского класса (базовой реализации метода в классе `button`).

    DOM.decl({ block: 'mybutton', baseBlock: 'button' }, {
        method: function() {
            this.__base();
            this.doMore();
        }, 
        {}
    });

	
# Состояния блока #

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор **состояний** блока.
Тогда поведение блока определяется действиями, которые нужно
выполнить при переходе из одного состояния в другое. 

Такой подход позволяет писать код блока в декларативном стиле как
набор утверждений вида:

* Описание состояния — действия, выполняемые при переходе в данное состояние.

## Модификаторы ##

Согласно БЭМ-методологии, состояние блока и его элементов описывается
**модификаторами**.

* Модификатор это **имя** и **значение**. Например, `size`: `m`.
* Модификатор может не иметь значения. Например, `disabled`.
* Каждому блоку можно назначить один или несколько модификаторов.
* Блок может не иметь модификаторов.

В i-bem.js модификаторы могут быть назначены (менять значения):

* при инициализации блока;
* в ходе выполнения кода блока (например, в качестве реакции на DOM-события);
* по запросу из другого блока. Подробнее см. События FIXME

Действия, выполняемые при установке модификаторов, описываются в
декларации блока. Для этого в хэше методов экземпляра блока
зарезервированы свойства:

* `onSetMod` — callback-функции, вызываемые при установке
  *модификаторов блока*.
* `onElemSetMod` — callback-функции, вызываемые при установке
  *модификаторов элементов* блока.

		modules.define('i-bem__dom', function(provide, DOM) {

		DOM.decl(/* селектор блока \*/,
			{ 
				/* методы экземпляра \*/
				onSetMod: { /* действия при установке модификаторов	блока */ }
				onElemSetMod: { /* действия при установке модификаторов элементов */ }
			},
			{
				/* статические методы \*/
			}
		);

		provide(DOM);
		});


### Синтаксис `onSetMod` ###

Описание callback-функций для onSetMod представляет собой хеш вида:

Метод onSetMod связывает callback-функции с именами и значениями
модификаторов блока. 

    {
        'модификатор1' : {
    
            'значение1-модификатора1' : function() { ... }, // функция, которая будет вызвана при установке модификатора 'модификатор1' в значение 'значение1'
    
            ...
    
            'значениеN-модификатора1' : function() { ... }, // функция, которая будет вызвана при установке модификатора 'модификатор1' в значение 'значениеN'
    
            '*' : function() { ... } // функция, которая будет вызвана при установке модификатора 'модификатор1' в любое из значений
    
        },
    
        'модификатор2' : function() {}, // функция, которая будет вызвана при установке модификатора 'модификатор2' в любое из значений
    
        ...
    
        'модификаторN' : {
    
            'значение1-модификатораN' : function() { ... },
    
            ...
    
            'значениеN-модификатораN' : function() { ... }
    
        }
    
    }

### Синтаксис `onElemSetMod` ###

    {
    
        'элемент1' : {
    
            'модификатор1' : {
    
                'значение1-модификатора1' : function() { ... }, // функция, которая будет вызвана при установке модификатора 'модификатор1' в значение 'значение1' для элемента 'элемент1'
    
                ...
    
                'значениеN-модификатора1' : function() { ... }, // функция, которая будет вызвана при установке модификатора 'модификатор1' в значение 'значениеN' для элемента 'элемент1'
    
                '*' : function() { ... } // функция, которая будет вызвана при установке модификатора 'модификатор1' в любое из значений  для элемента 'элемент1'
    
            }
    
        },
    
        ...
    
        'элементN' : function() { }, // функция, которая будет вызвана при установке любого модификатора в любое из значений для элемента 'элементN'
    
    }


### Параметры callback-функций ###

### Порядок вызова функций при установке модификатора ###



Callback функции, реагирующие на изменение модификатора, выполняются
до установки модификатора. Если существует необходимость выполнить
часть кода после установки модификатора, нужно воспользоваться методом
.afterCurrentEvent().


NB: Модификаторы нельзя устанавливать, напрямую меняя CSS класс на соответствующей DOM-ноде. 

## Инициализация ##

DOM-представление инциализированного блока:

    <div class="b-my-block b-my-block_js_inited i-bem" onclick="return {
        'b-my-block' : {
            'name' : 'b-my-block'
        }
    }">
    ..
    </div>

### Автоматическая инициализация блоков ###

### Live-инициализация ###

## Деструкция ##

NB: в bem-core установка модификатора js в пустое значение будет вызывать деструктор

# События #
	
# Взаимодействие блоков #

Может возникнуть необходимость управлять другим блоком. Для любых
манипуляций с блоком необходимо получить доступ к js-объекту этого
блока и вызывать его методы.

## Блоки ##

`BEM.blocks['name']`

## Элементы ##

NB: Напрямую блок к элементу другого блока не может обратиться, только через блок.

## Модификаторы ##

# Справочник #

## Зарезервированные имена параметров ##

В i-bem.js зарезервированы следующие имена параметров, которые обрабатываются особым образом при инцииализации
всех блоков.

* **id**
    Параметр `id` позволяет размещать один блок на нескольких DOM-узлах. Для этого на обоих узлах в параметрах 
    данного блока указывается один и тот же `id`:

    
    <div class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></div>
    ...
    <span class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></span>

## Общие методы блоков ##


# Примеры #

## Кастомизация блоков ##




