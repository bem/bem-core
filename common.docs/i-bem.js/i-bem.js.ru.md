<!--# i-bem.js: Руководство пользователя-->

# Общие сведения #

## i-bem.js: Клиентский Javascript-фреймворк для БЭМ ##

i-bem.js — специализированный JavaScript-фреймворк для веб-разработки в рамках [БЭМ-методологии](http://ru.bem.info/method/). 
С помощью i-bem.js можно:

 * разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
 * описывать логику работы блока в декларативном стиле — как набор состояний;
 * легко интегрировать JavaScript-код с CSS в стиле БЭМ и BEMHTML-шаблонами;
 * гибко переопределять поведение библиотечных блоков.

i-bem.js не может:

 * работать с состоянием на сервере (только клиентский JavaScript);
 * заменить высокоуровневые фреймворки общего назначения, подобные jQuery.

## БЭМ-методология и JavaScript ##

С точки зрения БЭМ-методологии веб-интерфейс строится из независимых **блоков** (внутри которых могут 
быть выделены **элементы**). И блоки, и элементы могут иметь состояния, описываемые **модификаторами**.

Работа веб-интерфейса обеспечивается несколькими **технологиями** (HTML, CSS, JS...), 
и описание блока складывается из реализаций в этих технологиях. Обычно реализация разбита на несколько файлов, например:

 * `block.css` — описывает внешний вид блока;
 * `block.bemhtml` — шаблоны для генерации HTML-представления блока;
 * `block.js` — описывает **поведение** блока.

Фреймворк i-bem.js позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:

 + **Блок** — JS-компонент, описывающий логику работы однотипных элементов интерфейса. Например, все кнопки могут быть реализованы
 с использованием блока `button`. Тогда, в соответствии с БЭМ-методологией, `button.css` определяет внешний вид всех кнопок, 
 а `button.js` — их логику работы.  
 + На каждой странице может размещаться более одного **экземпляра** блока. Каждому экземпляру блока соответствует JS-объект, 
 динамически создаваемый в памяти браузера и хранящий состояние данного экземпляра блока.
 + **Элементы** — Особые поля в структуре данных экземпляра блока.  
 + **Модификаторы** — Особые поля экземпляра блока, хранящие информацию о состоянии блока и его элементов.



## Как использовать i-bem.js ##

Фреймворк i-bem.js входит в состав библиотеки [bem-core](http://github.com/bem/bem-core/).

Можно использовать i-bem.js как часть полного стека БЭМ-инструментов. Свой проект удобно создавать 
на основе шаблонного репозитория [project-stub](http://github.com/bem/project-stub/), в котором 
подключены все необходимые библиотеки и настроена установка БЭМ-инструментов. 

Если не планируется использование других технологий БЭМ-платформы, можно
подключить библиотеку bem-core в существующий проект любым доступным способом.

Исходный код i-bem.js — JS-реализация блока [i-bem](http://github.com/bem/bem-core/tree/v1/common.blocks/i-bem/).
Существенные компоненты реализации: 

 * Прототип описания блока `i-bem.vanilla.js`
 * Реализация элемента [i-bem__dom](https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/\_\_dom/i-bem\_\_dom.js).
 * Внутренние хелперы `i-bem__internal.vanilla.js`

Зависимости: 

 * jQuery. При использовании bem-core отдельная установка jQuery не требуется.
 * Модульная система [ymaps/modules](https://github.com/ymaps/modules). 

## Сборка ##

Разработка в рамках БЭМ-методологии ведется модульно: каждый блок программируется отдельно, финальный исходный
код веб-страниц формируется из описаний блоков с помощью процедур **сборки**.

В файловой системе блок удобно представлять в виде каталога, а реализацию блока 
в каждой из технологий — в виде отдельного файла:

    desktop.blocks/
        myblock/
            myblock.css
            myblock.js
            myblock.bemhtml
            ...

    desktop.blocks/
        otherblock/
            otherblock.css
            otherblock.js
            otherblock.bemhtml
            ...

Для каждой веб-страницы код использованных на ней блоков должен быть собран в единые файлы: 

    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...

Автоматизацию сборки кода результирующих веб-страниц из отдельных описаний блоков осуществляют
инструменты пакета [bem-tools](http://github.com/bem/bem-tools/). 

*?? Можно ли пользоваться i-bem.js, не используя bem-tools?*

## Почему i-bem.js так называется ##

В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и 
гибко переопределять поведение библиотеки на разных уровнях переопределения.

Служебным блокам в БЭМ было принято давать имена с префиксом `i-`. Таким образом, имя `i-bem.js` 
читается как «реализация блока `i-bem` в технологии `js`».


# Привязка блоков к HTML #

JavaScript-компоненты в i-bem.js служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — привязать обработку определенных событий к
указанному HTML-фрагменту. 

 * Первичным является DOM-дерево документа, в котором размечены блоки, элементы и модификаторы (в атрибутах `class` HTML-элементов). 
 * Таким образом, в DOM-дереве каждому экземпляру блока соответствует DOM-элемент.
 * Если блок имеет JavaScript-реализацию, к каждому упоминанию блока на странице (DOM-элементу) должен быть привязан JS-объект — экземпляр блока.
 * JS-объект, привязанный к DOM-элементу, обрабатывает происходящие на нем события и хранит состояние данного экземпляра блока.

Преимущества этого подхода к связи HTML и JavaScript-компонент: 

 * естественная деградация интерфейса на клиентах с отключенным JavaScript;
 * _прогрессивный рендеринг_ — возможность начать отрисовку элементов интерфейса до окончания загрузки всех данных страницы (например, изображений).


## Синтаксис привязки блоков ##

Чтобы привязать блок к HTML-элементу, необходимо: 

 1. **Отметить блок в DOM-дереве**.<br/>
 Включить имя блока в список классов HTML-элемента (атрибут `class`).
 2. **Инициализировать экземпляр блока**.<br/> 
 Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.
 3. **Передать параметры экземпляру блока**.<br/>
 Поместить параметры блока в атрибут `onclick`. Параметры блока представляют собой JS-хэш структуры __имя блока—хэш параметров__. 
 Параметры передаются экземпляру блока в момент инициализации.

Соотношение блоков и DOM-элементов не обязательно должно быть
одно-однозначным. Возможны следующие типы связи: 
 
### Один DOM-элемент — один JS-блок ###

Самый простой и распространенный способ привязки блоков к HTML.

Пример: HTML-элемент `div`, на котором размещен блок `myblock`, параметры блока — пустой список `{}`.

    <div class="myblock i-bem"
        onclick="return { 
            myblock: {},
        }">
        <span class="myblock__item"></span>
     </div>



<a name="mixes"></a>

### Один DOM-элемент — несколько JS-блоков ###

Техника размещения нескольких блоков на одном DOM-элементе в БЭМ-методологии называется **микс**. 

Пример: HTML-элемент `div`, на котором размещены блоки `myblock` и `anotherblock`, параметры обоих блоков — пустой список `{}`.

    <div class="myblock anotherblock i-bem"
        onclick="return { 
            myblock: {},
            anotherblock: {}
        }">
        <span class="myblock__item"></span>
     </div>


### Один JS-блок на нескольких DOM-элементах ###

Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из нескольких компонент, 
сосотяние которых должно быть согласовано. Например, виджет «вкладки», где клик по заголовку 
вкладки (один HTML-элемент), меняет содержимое вкладки (другой HTML-элемент). Другой пример —
маркер, обозначающий точку на карте (первый элемент) и связанное с ним описание точки в списке рядом с картой (второй элемент).

Чтобы привязать блок к нескольким DOM-элементам, нужно в параметрах блока на обоих HTML-элементах
указать одинаковое значение `id`.

Пример: Блок `notebook` привязан к HTML-элементам `div` и `span`, в параметрах блока указан общий `id` — `notebook`.

    <div class="notebook i-bem"
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </div>

    ...
    
    <span class="notebook i-bem" >
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </span>


В результате при инциализации блоков будет создан один JS-объект,
содержащий ссылки на оба DOM-узла в поле [`domElem`](). 



<a name="i-blocks"></a>

### Блоки без DOM-представления ###

Инфраструктурный код, решающий общие задачи интерфейса: связь с бэкэндом, общие вычисления и т.п. — при работе с i-bem.js 
можно оформлять в виде блока, как и весь прочий JS-код. Чтобы не привязывать такие блоки к DOM-дереву икусственно, 
i-bem.js предоставляет возможность создавать блоки без DOM-представления. 

Блоки без DOM-представления:

 * В HTML-коде страницы не указываются.
 * JS-код блока (декларация) пишется с использованием несколько иного синтаксиса, чем для блоков с DOM-представлением. Подробнее см. FIXME. 

**NB**: В общем случае инфраструктурный код следует оформлять не в виде блока без DOM-представления, а в виде ymaps-модуля. Например: 

    modules.define('router', function(provide) {

    provide({
        route : function() { ... }
    });

    });



## Синтаксис передачи параметров ##

Параметры блока — произвольный JavaScript-объект, который будет передан блоку в момент инициализации. 
Параметры позволяют модифицировать поведение экземпляра блока, привязанного к данному DOM-узлу.

В значении атрибута `onclick` указываются параметры _всех JS\_блоков, размещенных на данном узле_. 
Параметры передаются с помощью конструкции `return` в виде хэша:

 + ключ — имя блока;
 + значение — хэш параметров данного блока. Если данному экземпляру блока не требуются 
   параметры, указывается пустой хэш `{}`.

Такой формат параметров продиктован следующими соображениями:

 * Указание имени блока в параметрах позволяет избежать необходимости парсить значение атрибута `class`,
   что упрощает и ускоряет инициализацию блоков. Это же решение позволяет размещать несколько блоков на одном 
   DOM-узле без необходимости множить атрибуты элемента.
 * Передача параметров в виде нативного JS-объекта позволяет обходиться для этой цели одним HTML-атрибутом
   и передавать в качестве параметров произвольный JS-код.

*NB: на некоторых уровнях переопределения для передачи блока может использоваться другой HTML-атрибут. Например, в 
библиотеке bem-bl для блоков сенсорных интерфейсов используется атрибут `ondblclick`.*

# Декларация блока #

JS-реализация блока описывает функциональность определенного класса элементов веб-интерфейса. В конкретных 
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует 
функциональность всего класса и имеет собственное состояние, независимое от остальных.

В терминах парадигмы объектно-ориентированного программирования: 

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в _методах_ класса (= блока). 
Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в i-bem.js принято называть **декларацией**, чтобы подчеркнуть принятый в БЭМ декларативный
стиль программирования. В соответствии с декларативным стилем поведение блока программируется как 
утверждения вида _набор условий — реакция блока_.

	
## Синтаксис декларации ##

Чтобы декларировать новый JS-блок, необходимо переопределить ymaps-модуль `i-bem__dom`. 

Блоки, имеющие DOM-представление (привязанные к DOM-элементу) декларируются с помощью 
метода `DOM.decl`, принимающим три параметра: 

1. Селектор блока — строка (имя блока) или хэш (описание блока). Подробнее см. FIXME
2. Методы экземпляра блока — хэш.
3. Статические методы — хэш.

        modules.define('i-bem__dom', function(provide, DOM) {
        
        DOM.decl(/* селектор блока \*/,
            { 
                /* методы экземпляра \*/
            },
            {
                /* статические методы \*/
            }
        );
        
        provide(DOM);
        });

Блоки, не имеющие DOM-представления, декларируются как доопределение ymaps-модуля `i-bem`. 
Вместо метода `DOM.decl` используется метод `BEM.decl`, принимающий те же параметры: 

    modules.define('i-bem', function(provide, BEM) {

    BEM.decl(/* селектор блока \*/,
        { 
            /* методы экземпляра \*/
        },
        {
            /* статические методы \*/
        }
    );
    
    provide(BEM);
    });


<a name="decl_selector"></a>

## Селектор блока ##

Селектор представляет собой описание блока, в котором будут применяться
объявленные в декларации методы.  Селектор обязательно содержит имя блока и 
может содержать условия, ограничивающие сферу действия методов определенной
модификацией блока или наличием других блоков на том же DOM-узле.

Селектор может быть задан в одной из двух форм:

1. Имя блока — строка. 
   Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).
Пример: декларация методов для блока `button`.

        DOM.decl('button',
            { 
                /* методы экземпляра \*/
            },
            {
                /* статические методы \*/
            }
        )

2. Описание блока — хэш.
   В описании зарезервированы следующие ключи:

   * `block` (строка) — имя блока, обязательный параметр.

   * `baseBlock` (строка) — Имя родительского блока (класса). Данный
     блок наследует все методы родительского блока.

   * `baseMix` (массив) — Имена дополнительных родительских блоков,
     позволяет реализовать множественное наследование. Данный блок
     наследует методы всех указанных родительских блоков.

   * `modName` (строка) — Имя модификатора блока. Объявленные методы
     будут привязаны только к экземплярам блока с указанными
     значениями модификатора. Если не указан параметр `modVal`,
     селектор применяется к блокам с указанным модификатором
     независимо от его значения.

   * `modVal` (строка/массив) — Значение или массив значений
     модификатора блока.  Объявленные методы будут привязаны только к
     экземплярам блока с указанными значениями
     модификатора. Предполагает указание параметра `modName`.

Примеры:

Декларация методов для блока `button` с модификатором `pseudo` в значении `yes` (описывает поведение псевдокнопок):

    DOM.decl({ block: 'button', modName: 'pseudo', modVal: 'yes' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )

Блок `checkbutton` наследует блокам `button` и `checkbox`:

    DOM.decl({ block: 'checkbutton', baseBlock: 'button', baseMix: 'checkbox' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )
 


## Контекст ##

В коде блока контекстом всегда является JS-объект экземпляра блока, а
не DOM-элемент, на котором размещен блок. Ссылка на экземпляр блока
(контекст) доступна в коде блока посредством ключевого слова `this`.

**NB**: Для обращения к DOM-элементу блока используется общий метод
  блоков `getElem`. Подробнее см. FIXME.

Контекст содержит зарезервированные поля:

 + `this.__self`: Ссылается на статические методы класса, к которому принадлжит экземпляр.

Пример: Вызов статического метода в методе экземпляра блока.

    DOM.decl('myblock', {
        method: function() {
            this.__self.staticMethod();
            this.doMore();
        }, 
        {}
    });


 + `this.__base`: Ссылается на реализацию метода в базовом классе, которому наследует данный.
    Позволяет выполнить super call. 

Пример: вызов (и модификация) метода родительского класса (базовой реализации метода в классе `button`).

    DOM.decl({ block: 'mybutton', baseBlock: 'button' }, {
        method: function() {
            this.__base();
            this.doMore();
        }, 
        {}
    });

	
# Состояния блока #

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор **состояний** блока.  Тогда
поведение блока определяется **триггерами** — callback-функциями, которые
выполняются при переходе блока из одного состояния в другое.

Такой подход позволяет писать код блока в декларативном стиле как
набор утверждений вида:

* Описание состояния — действия, выполняемые при переходе в данное состояние.

## Модификаторы ##

Согласно БЭМ-методологии, состояние блока и его элементов описывается
**модификаторами**.

* Модификатор это **имя** и **значение**. Например, `size`: `m`.
* Модификатор может не иметь значения. Например, `disabled`.
* Каждому блоку можно назначить один или несколько модификаторов.
* Блок может не иметь модификаторов.

В i-bem.js модификаторы могут быть назначены (менять значения):

* при инициализации блока;
* в ходе выполнения кода блока (например, в качестве реакции на DOM-события);
* по запросу из другого блока. Подробнее см. События FIXME

### Управление модификаторами ###

Экземпляр блока предоставляет методы для установки и удаления
модификаторов. Эти же методы используются для управления
модификаторами элементов блока. В качестве первого (необязательного)
параметра все методы принимают имя элемента:

* `{BEM} this.setMod([elem], modName, modVal)` — Установить модификатор
  `modName` в значение `modVal`. Возвращает JS-объект блока.
* `{Boolean} this.hasMod([elem], modName, [modVal])` — Проверить
  наличие модификатора `modName` со значением `modVal` (опционально). 
* `{String} this.getMod([elem], modName)` — Получить значение
  модификатора `modName`.
* `{Object} this.getMods([elem], [modNames])` — Получить хэш значений
  модификаторов блока. Необязательный параметр `modNames` позволяет
  указать список модификаторов (через запятую), значения которых нужно
  вернуть.
* `{BEM} this.toggleMod([elem], modName, modVal1, modVal2,
  [condition])` — Переключить значение модификатора `modName`. Если
  передан параметр `condition`, выставить `modVal1`, если `true` и
  `modVal2` в обратном случае. Если параметр `condition` не передан,
  то выставить `modVal2`, если текущее значение модификатора `modVal1`
  и наоборот.

-------------------------------------------------------------------------------

**NB**: Модификаторы нельзя устанавливать, напрямую меняя CSS класс на
соответствующем DOM-узле. Для изменения значений модификаторов следует
использовать API, предоставляемое i-bem.js.

-------------------------------------------------------------------------------

## Триггеры ##

Выполнение триггеров разбито на две фазы:

1. **До установки модификатора**. Эта фаза зарезервирована для
   возможности **отменить** установку модификатора. Если хотя бы один
   из триггеров, выполняемых в этой фазе, вернет `false`, установки
   модификатора не произойдет.
2. **После установки модификатора**. Триггеры, выполняемые в этой
   фазе, уже не могут отменить установку модификаторов.

Триггеры могут быть привязаны к следующим типам событий:

1. установка *любого* модификатора в *любое* значение;
2. установка модификатора `modName` в *любое* значение (в том числе
   установка модификатора *без значения*);
3. установка модификатора `modName` в значение `modVal`;
4. удаление модификатора `modName` (эквивалентно установке в качестве
   значения модификатора пустой строки `''`).

При установке модификатора `modName` в значение `modVal` триггеры
каждой фазы (если они определены) вызываются в том порядке, в котором они
перечислены в приведенном выше списке событий.

Таким образом, при определении триггера пользователь указывает:

* фазу выполнения (до или после установки модификатора);
* тип события (имя и значение модификатора).

### Декларация триггеров ###

Триггеры, выполняемые при установке модификаторов, описываются в
декларации блока. Для этого в хэше методов экземпляра блока
зарезервированы свойства:

* `beforeSetMod` — триггеры, вызываемые до установки
  **модификаторов блока**. 
* `beforeElemSetMod` — триггеры, вызываемые до установки
  **модификаторов элементов**.
* `onSetMod` — триггеры, вызываемые после установки
  *модификаторов блока*.
* `onElemSetMod` — триггеры, вызываемые после установки
  *модификаторов элементов* блока.

		modules.define('i-bem__dom', function(provide, DOM) {

		DOM.decl(/* селектор блока */,
			{ 
				/* методы экземпляра */
				
				beforeSetMod: { /* триггеры до установки модификаторов блока*/}

				beforeElemSetMod: { /* триггеры до установки модификаторов элементов*/}

				onSetMod: { /* триггеры после установки модификаторов блока */ }
				
				onElemSetMod: { /* триггеры после установки модификаторов элементов */ }
			},
			{
				/* статические методы \*/
			}
		);

		provide(DOM);
		});


Значение свойств `beforeSetMod` и `onSetMod` — хэш, связывающий изменения модификаторов с триггерами:

	{
		'mod1': function() { ... }, // триггер на установку mod1 в любое значение
		'mod2': {
			'val1': function() { ... }, // триггер на установку mod2 в значение val1
			'val2': function() { ... } // триггер на установку mod2 в значение val2
		},
		'*': function() { ... } // триггер на установку любого модификатора в любое значение
	}

Для триггера на установку любого модификатора блока в любое значение
существует сокращенная форма записи:

	beforeSetMod: function() { ... }
	onSetMod: function() { ... }
	
Для свойств `beforeElemSetMod` и `onElemSetMod` в хэш значений
добавляется дополнительный уровень вложенности, задающий **элемент**,
на установку модификаторов которого устанавливаются триггеры:
	
	{
		'elem1': {
			'mod1': function() { ... }, // триггер на установку mod1 элемента elem 1 в любое значение 
			'mod2': {
				'val1': function() { ... }, // триггер на установку	mod2 элемента elem1 в значение val1
				'val2': function() { ... } // триггер на установку mod2 элемента elem1 в значение val2
				}
			},
			
		'elem2': function() { ... } // триггер на установку любого модификатора элемента elem2 в любое значение
	}

Сокращенная запись для триггера на установку любого модификатора элемента
`elem1` в любое значение:

	beforeElemSetMod: { 'elem1': function() { ...} }
	onElemSetMod: { 'elem1': function() { ...} }

### Параметры триггеров ###

Всем callback-функциям, определенным в качестве триггеров на установку
модификаторов, передаются следующие параметры: 

* `{jQuery} [elem]` — Имя элемента. Необязательный параметр, только
  для триггеров на модификаторы элементов.
* `{String} modName` — Имя модификатора.
* `{String} modVal` — Устанавливаемое значение модификатора. **FIXME**:
  значение, если модификатор удаляется.
* `{String} curModVal` — Текущее значение модификатора. **FIXME**:
  значение, если модификатора не было.

## Инициализация ##

Инициализация блока — это создание в памяти браузера JS-объекта,
соответствующего экземпляру блока. Инициализация блока выполняется
функцией [`DOM.init()`]() на фрагменте DOM-дерева.

Каждому блоку можно приписать три состояния:

* блок не инициализирован (JS-объект не создан);
* блок инициализирован (JS-объект создан в памяти браузера);
* блок уничтожен (JS-объект удален из памяти браузера).

В i-bem.js эти состояния блока описываются с помощью служебного
модификатора `js`.

* До инициализации блок не имеет модификатора `js`.
* В момент инициализации блоку устанавливается модификатор `js` в
  значении `inited`.
* При уничтожении блока модификатор `js` удаляется.

DOM-представление инициализированного блока:

    <div class="myblock myblock_js_inited i-bem"
		onclick="return { 'myblock' : {} }">
    ...
    </div>

Если на DOM-узле размещено несколько блоков, то инициализация одного
из них (появление модификатора `block_js_inited`) не влияет на
инициализацию остальных.

-------------------------------------------------------------------------------

**NB** Наличие модификатора `js` позволяет писать разные CSS-стили для
  блока в зависимости от того, инициализирован он или нет.

-------------------------------------------------------------------------------


### Конструктор блока ###

На изменение значений модификатора `js` можно назначать триггеры так
же, как и для любых других модификаторов блока.

Триггер на установку модификатора `js` в значение `inited` является
первой функцией, выполняющейся при создании блока. Такой триггер можно
назвать **конструктором экземпляра блока**:

	onSetMod: {
		'js': {
			'inited': function() { ... } // конструктор экземпляра блока
		}
	}


### Деструктор блока ###

Триггер на удаление модификатора `js` (установку в пустое значение `''`) является
последней функцией, выполняемой перед удалением блока. Такой триггер
можно назвать **деструктором экземпляра блока**.

	onSetMod: {
		'js': {
			'': function() { ... } // деструктор экземпляра блока
		}
	}
	

### Автоматическая инициализация всех блоков ###

Фреймворк i-bem.js позволяет автоматически инициализировать все блоки,
имеющиеся на странице в момент наступления события `domReady`. Для
этого необходимо задекларировать на странице блок `i-bem` с
модификатором `init` в значении `auto`. Пример файла `.deps.js`:

    ({
        mustDeps: [
            {
                block: 'i-bem',
                elem: 'dom',
                mods: { 'init': 'auto' }
            }
        ]
    })

При автоматической инициализации в памяти браузера будут созданы
JS-объекты для всех DOM-узлов, в атрибуте `class` которых указан класс
`i-bem`, а также для всех блоков, задекларированных как блоки, [не
имеющие DOM-представления]().


### Инициализация по событию (live-инициализация) ###

Автоматическая инициализация всех блоков в момент загрузки страницы
может быть нежелательной, так как при большом количестве экземпляров
блоков на странице увеличивается время загрузки и объем затраченной
памяти браузера.

В этом случае имеет смысл инициализировать JS-объекты только в тот
момент, когда их функциональность потребуется пользователю, например,
по клику на блоке. Такая инициализация называется **ленивой** или
**live-инициализацией**.

Для описания условий ленивой инициализации зарезервировано свойство
`live` в разделе статических методов декларации блока:

	modules.define('i-bem__dom', function(provide, DOM) {

	DOM.decl(/* селектор блока */,
		{ 
			/* методы экземпляра */
		},
		{
			/* статические методы */
			live: { ... } // условия инициализации по событию
		}
	);

	provide(DOM);
	});

-------------------------------------------------------------------------------

**NB** Свойство `live` задает ленивую инициализацию для *всех
  экземпляров* соответствующего блока, т.к. технически относится к
  статическим методам класса блока. Поэтому даже если свойство `live`
  задекларировано для блока с определенным значением модификатора, оно
  будет применено ко всем таким блокам вне зависимости от модификаторов.

-------------------------------------------------------------------------------


Свойство `live` может принимать два типа значений:

* `Boolean`.<br/>
  Если `live` установлено в значение `true`, блок будет
  инициализирован только при обращении к нему из другого
  блока. Подробнее см. раздел [Взаимодействие блоков](#api).
  
* `Function`.<br/>
  Функция, указанная в качестве значения `live`, будет выполнена один
  раз — при попытке инициализации первого экземпляра блока, заданного
  [селектором](#decl_selector) в декларации блока.
  В этой функции следует выполнить подписку на событие, при
  наступлении которого нужно инициализировать блок. 

В i-bem.js определены хелперы для вызова callback-функций в момент
инициализации по событию:

* `liveInitOnEvent('событие', callback)` — инициализация по событию на блоке или его
  элементе.<br/>
  Callback-функция будет вызвана один раз при инициализации блока.
* `liveBindTo('событие', callback)` — подписка на событие.<br/>
  Callback-функция будет вызываться каждый раз при наступлении события
  на экземпляре блока.

Callback-функция принимает один параметр — **FIXME**.


Пример блока, экземпляры которого будут инициализированы по первому
клику на соответствующем DOM-элементе. При инициализации будет вызван
метод `_onClick` экземпляра блока:

	modules.define('i-bem__dom', function(provide, DOM) {

	DOM.decl(/* селектор блока */,
		{ 
			/* методы экземпляра */
			onClick: function(e) { ... }
		},
		{
			/* статические методы */
			live: function() {
				this.liveBindTo('click', function(e) {
					this._onClick(e);
				});
			} 
		}
	);

	provide(DOM);
	});
	

# События #
	
В i-bem.js поддерживается два вида событий:

* **DOM-события** — JavaScript-события, возникающие на DOM-узлах,
  соответствующих блокам. Это события, отражающие взаимодействие
  пользователя с интерфейсом (клик, наведение мыши, ввод текста и
  т.п.)
* **BEM-события** — собственные события, которые генерируются
  блоками. Позволяют организовать API для взаимодействия с блоком.

## DOM-события ##

Для привязки обработчиков к DOM-событиям на узлах, связанных с блоком
или элементом, используются методы экземпляра блока `this.bindTo` и `this.unbindFrom`.

* `bindTo([elem], event, handler)` — Подписаться на событие на
  DOM-узле блока или элемента.
  
	  Параметры:
  
	  * `{jQuery|String} [elem]` — Элемент блока. Необязательный параметр.
	  * `{String} event` — Список имен DOM-событий, разделенных пробелом.
	  * `{Function} handler` — Функция-обработчик события.

* `unbindFrom([elem], event)` — Отменить подписку на событие
  на DOM-узле блока или элемента.
  
	  Параметры:
  
	  * `{jQuery|String} [elem]` — Элемент блока. Необязательный параметр.
	  * `{String} event` — Список имен DOM-событий, разделенных пробелом.

**Пример**: В момент инициализации (в конструкторе экземпляра блока)
выполняется подписка на событие `click`, при наступлении которого блок
выставляет себе модификатор `size` в значение `big`.

    onSetMod : { 

        'js' : {
			'inited': {
				function() {
					var square = this; // FIXME: зачем это нужно?
					
					this.bindTo('click', function(){
						square.setMod('size', 'big');
					}); 
				}
			}
		}
	}


## BEM-события ##

В отличие от DOM-событий, BEM-события генерируются блоками. Элементы
блоков не могут генерировать BEM-события.

Чтобы сгенерировать событие, используется метод экземпляра блока
`this.emit`:

* `emit(event, [data])` — Сгенерировать BEM-событие.

	Параметры:
	
	* `{String} event` — Имя события.
	* `{Object} [data]` — Данные, передаваемые обработчику
      события. Необязательный параметр. Обработчик получает переданный
      в этом параметре объект как второй (необязательный) параметр
      `data`.

Для привязки обработчиков к BEM-событиям блоков используются методы
экземпляра блока `this.on` и `this.un`.

В i-bem.js поддерживаются два типа подписки на события:

* Подписка на события конкретного экземпляра блока. Выполняется при
обращении к JS-объекту экземпляра блока. **FIXME** — реалистичный
мини-пример подписки на событие блока.
* **Статический бинд** — подписка на событие всех блоков с заданным
  именем в пределах контекста `ctx`: **FIXME** — реалистичный
мини-пример статического бинда.

		.on(ctx, event, handler)
	
Синтаксис методов:

* `on([ctx], event, [data], handler, [fnCtx])` — Подписка на
  BEM-событие.

	Параметры:
	
	* `{jQuery} [ctx]` — **FIXME** элемент(?) на котором будет слушаться
      событие. Необязательный параметр.
	* `{String} event` — Имя события.
	* `{Object [data]}` — Дополнительные данные, передаваемые
      обработчику события. Необязательный параметр. Данные доступны в
      обработчике как поле `e.data` (`e` — контекст события,
      передаваемый обработчику в качестве аргумента).
	* `{Function} handler` — Функция-обработчик события.
	* `{Object} fnCtx` — Контекст функции-обработчика. Необязательный
      параметр. **FIXME** зачем его передавать?

* `un([ctx], event, handler, [fnCtx])` — Удаление подписки на
  BEM-событие.

	Параметры:

	* `{jQuery} [ctx]` — **FIXME** элемент(?) на котором слушалось
      событие. Необязательный параметр.
	* `{String} event` — Имя события.
	* `{Function} handler` — Функция-обработчик события.
	* `{Object} fnCtx` — Контекст функции-обработчика. Необязательный
      параметр.


<a name="api"></a>


## Контекст события (структура данных) ##

Функциям-обработчикам событий в качестве единственного параметра
передается контекст события, который содержит следующие поля:

* `domElem` — DOM-элемент, на котором возникло событие.
* `data` — Произвольные дополнительные данные. В BEM-событиях
  передается в качестве параметра `data` в момент подписки на событие
  или при создании события блоком.
* **FIXME**: что еще?


# Взаимодействие блоков #

БЭМ-методология предполагает, что блоки должны разрабатываться таким
образом, чтобы по возможности исключить зависимость состояний одних
блоков от других. Однако на практике идеал полной независимости блоков
недостижим.

Чтобы реализовать взаимодействие блоков, необходимо получить JS-объект
экземпляра блока и вызвать его методы. i-bem.js предоставляет API для
доступа к блокам и элементам.

## Поиск блоков в DOM-дереве ##

Обращение к другому блоку в i-bem.js выполняется из текущего блока,
размещенного на определенном узле DOM-дерева. Поиск других блоков в
DOM-дереве может вестись по трем направлениям (осям) относительно
DOM-узла текущего блока:

* «Внутри блока» — на DOM-узлах, вложенных в DOM-узел текущего блока.
* «Снаружи блока» — на DOM-узлах, потомком которых является DOM-узел
  текущего блока.
* «На себе» — на том же DOM-узле, на котором размещен текущий
  блок. Это актуально в случае [размещения нескольких JS-блоков на
  одном DOM-узле](#mixes) (микс). 

-------------------------------------------------------------------------------

**NB** Не используйте jQuery-селекторы для поиска блоков и элементов.

-------------------------------------------------------------------------------

Для поиска блоков и их элементов в DOM-дереве определены следующие
методы экземпляра блока: 

* `{BEM} findBlockInside([elem], block)` — Первый указанный блок
  (элемент этого блока) внутри текущего блока.
* `{BEM[]} findBlocksInside([elem], block)` — Коллекция указанных
  блоков (элементов этих блоков) внутри текущего блока.
* `{BEM} findBlockOutside([elem], block)` — Первый указанный блок
  (элемент этого блока) снаружи текущего блока.
* `{BEM[]} findBlocksOutside([elem], block)` — Коллекция указанных
  блоков (элементов этих блоков) снаружи текущего блока.
* `{BEM} findBlockOn([elem], block)` — Первый указанный блок
  (элемент этого блока) на DOM-узле текущего блока.
* `{BEM[]} findBlocksOn([elem], block)` — Коллекция указанных
  блоков (элементов этих блоков) на DOM-узле текущего блока.

Параметры методов:

* `{String|jQuery} elem` — Элемент блока. Необязательный параметр.
* `{String|Object} block` — Искомый блок. Может быть указан двумя
  способами:

	* `{String}` — Имя блока.
	* `{Object}` — Хэш, описывающий блок и значение модификатора, при
      наличии которого следует вернуть блок. Зарезервированы поля:

	* `block` — имя блока;
	* `modName` — название модификатора;
	* `modVal` — значение модификатора.


## Доступ к блокам без DOM-представления ##


JS-компоненты, соответствующие всем блокам («классы» блоков), хранятся
в структуре данных `BEM.blocks`. Классы блоков,
[не привязанных к DOM-дереву](#i-blocks), также размещены в этой
структуре данных. При необходимости доступа к таким блокам следует
использовать конструкцию:

	BEM.blocks['name']

где `name` — имя блока.


## Поиск элементов ##

Экземпляр блока предоставляет методы для обращения к элементам данного
экземпляра:

* `{jQuery} this.elem(elems, [modName], [modVal])` — Получить
указанные элементы блока. Результат вызова этого метода кешируется,
поэтому нет необходимости сохранять его в переменную для повторного
использования.

	Параметры:

	* `{String} elems` — Список имен элементов, разделенный пробелами.
	* `{String} [modName]` — Имя модификатора, при наличии которого
      следует вернуть элемент. Необязательный параметр.
	* `{String} [modValue]` — Значение модификатора, при котором
      следует вернуть элемент. Необязательный параметр. Подразумевает
      указание `modName`.

	Возвращает jQuery-коллекцию **FIXME** DOM-элементов(?).

* `{jQuery} this.findElem([ctx], elems, [])` — Получить указанные элементы блока. Результат
  вызова метода не кешируется.

	Параметры:

	* `{jQuery} [ctx]` — **FIXME** DOM-элемент, в котором производится
      поиск.
	* `{String} elems` — Список имен элементов, разделенный пробелами. 
	* `{String} [modName]` — Имя модификатора, при наличии которого
      следует вернуть элемент. Необязательный параметр.
	* `{String} [modValue]` — Значение модификатора, при котором
      следует вернуть элемент. Необязательный параметр. Подразумевает
      указание `modName`.
	* `{Boolean} strictMode` — **FIXME**. Необязательный
      параметр. Значение по умолчанию — `false`.
	
# Справочник #

## Методы и свойства модуля DOM ##

Свойства:

* DOM.scope
* DOM.doc
* DOM.win

**FIXME** Нужно ли документировать этих:

* initBlock
* processParams
* findDomElem
* getParams
* extractParams
* cleanupDomNode
* removeDomNodeFromBlock

* DOM.decl

### DOM.init ###

Инициализирует JS-объекты экземпляров блоков на заданном фрагменте DOM-дерева.


Синтаксис: `{jQuery} init([ctx=scope])`

Параметры: 

* `{jQuery} ctx` — Корневой элемент фрагмента DOM-дерева, на
  котором следует инициализировать блоки. Необязательный
  параметр. Значение по умолчанию — `DOM.scope`

Возвращаемое значение:

* Контекст инициализации. **FIXME** что это такое?

### DOM.destruct ###

Удаляет JS-объекты экземпляров блоков на заданном фрагменте
DOM-дерева.

Синтаксис: `destruct(ctx, [excludeSelf=false])`

Параметры:

* `{jQuery} ctx` — Корневой элемент DOM-дерева, на котором следует
  удалить блоки.
* `{Boolean} excludeSelf` — **FIXME** Исключить корневой элемент?

### DOM.update ###

### DOM.replace ###

### DOM.append ###

### DOM.prepend ###

### DOM.before ###

### DOM.after ###



## Методы и свойства экземпляров блоков ##

### Зарезервированные свойства ###

#### this.domElem ####

Поле, содержащее ссылку на DOM-узел, на котором размещен блок.

`{jQuery this.domElem}`

### Поиск блоков ###

* findBlocksInside
* findBlockInside
* findBlocksOutside
* findBlockOutside
* findBlocksOn
* findBlockOn

### Поиск элементов ###

* findElem
* elem
* dropElemCache
* elemParams
* elemify

### Подписка на DOM-события ###

* bindToDomElem
* bindToDoc
* bindToWin
* bindTo
* unbindFromDomElem
* unbindFromDoc
* unbindFromWin
* unbindFrom

### Подписка на BEM-события ###

* emit
* on 
* un

### Ленивая инициализация (Подписка на Live-события) ###

* liveInitOnEvent
* liveBindTo
* liveUnbindFrom
* liveInitOnBlockEvent
* liveInitOnBlockInsideEvent
* 


### Управление модификаторами ###

* setMod

Определено в модуле BEM:
* hasMod 
* getMod
* getMods
* setMod
* toggleMod
* delMod
* 

### Параметры блока ###

* getDefaultParams

### Доступ к DOM-узлу блока ###

* containsDomElem

### Утилиты ###

* buildSelector
* nextTick

## Методы и свойства модуля BEM ##

**FIXME** нужно ли документировать, стоит ли делать отдельный раздел:

* BEM.blocks
* BEM.decl
* getName
* create

## Зарезервированные имена параметров ##

В i-bem.js зарезервированы следующие имена параметров, которые обрабатываются особым образом при инцииализации
всех блоков.

* **id**
    Параметр `id` позволяет размещать один блок на нескольких DOM-узлах. Для этого на обоих узлах в параметрах 
    данного блока указывается один и тот же `id`:

    
    <div class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></div>
    ...
    <span class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></span>

# Примеры #

## Кастомизация блоков ##




