# functions

Блок предоставляет набор вспомогательных методов для работы с функциями JavaScript.

Блок `functions` реализован в технологии `vanila.js` и подходит для использования как на клиенте, так и на сервере.

## Публичные методы блока

Доступен следующий набор методов:

### `isFunction`

Метод проверяет, является ли переданный ему аргументом объект функцией. В случае, если является, метод возвращает `true`.

```js
modules.require(['functions'], function(func) {
    var a = function(){},
        b = {};
    console.log(func.isFunction(a)); // true
    console.log(func.isFunction(b)); // false
});
```


### `noop`

Заготовка пустой функции (`function() {}`).

```js
modules.require(['functions'], function(func) {
    console.log(func.isFunction(func.noop)); // true
});
```

`noop` можно использовать в ситуациях, когда для работы требуется функция, но нет смысла добавлять логику. Например:
* для «прогрева» модулей. Если есть тяжелый модуль, которому для выполнения требуется время (например, для получения данных от файловой системы или бекенда), но результат его работы пока не нужен.

```js
modules.require(['functions'], function(func) {
    modules.require(['heavy'], func.noop);
    /* ... */ 
});
```

* в качестве «заглушки» для базовых классов при проектировании в парадигме ООП.

```js
modules.define('input', ['i-bem__dom', 'functions'], 
    function(provide, BEMDOM, func) {
        provide(BEMDOM.decl(this.name, {
            onSetMod: {
                js: {
                    inited: function() {
                        this.on('change', this._sendRequest);
                    }
                }
            },
            _sendRequest: func.noop,
            extraMethod: func.noop
    }));
});
```

## Элементы блока

Элементы блока реализуют набор методов — декораторов функций.

Декораторы добавляют функции дополнительную логику, не изменяя ее. Сигнатуры оригинальной и декорированной функции полностью совпадают.


### `debounce`

Декоратор позволяет объединить несколько вызовов функции, производимых в заданном временном интервале (далее **задержка**), в один. После каждой новой попытки вызова задержка начинает отсчитываться заново. 

В зависимости от значения аргумента `invokeAsap` `debounce` может работать в двух режимах:

1. Реальный вызов производится по истечению времени задержки после последней попытки вызова.
2. Реальный вызов производится сразу же при вызове декорированной функции. Последующие вызовы игнорируются, пока не истечет время задержки после последнего из них.

Декоратор принимает следующие аргументы:

* `fn` `{Function}` — оригинальная функция;
* `timeout` `{Number}` — время задержки в миллисекундах;
* `invokeAsap` `{Boolean}` — режим работы `debounce`. По умолчанию используется первый (соответствует значению `false`);
* `context` `{Object}` — контекст для выполнения оригинальной функции;

Для примера рассмотрим форму, при вводе данных в которую, на сервер должен отправляться запрос. Посылать запросы при каждом нажатии клавиши пользователем – слишком затратно. Можно декорировать обработчик и запрос будет отправляться через 500 миллисекунд после того, как пользователь прекратил ввод:

```js
modules.define('input', ['i-bem__dom', 'functions__debounce'], 
    function(provide, BEMDOM, debounce) {
        provide(BEMDOM.decl(this.name, {
            onSetMod: {
                js: {
                    inited: function() {
                        this.on('change', debounce(this._sendRequest, 500));
                    }
                }
            },
            _sendRequest: function() { console.log('request'); }
    }));
});
```


### `throttle`

Декоратор позволяет «затормозить» функцию. Она будет выполняться не чаще одного раза в указанный период, сколько бы раз в течение этого периода ни была вызвана. Все промежуточные вызовы будут игнорироваться.

Декоратор принимает следующие аргументы:

* `fn` `{Function}` — оригинальная функция;
* `period` `{Number}` — интервал между вызовами в миллисекундах;
* `context` `{Object}` — контекст для выполнения оригинальной функции;

Метод удобно использовать, например, для установки ресурсоемких обработчиков для часто генерируемых событий – `resize`, `pointermove` и т.п.:

```js
modules.define('slowdown', ['i-bem__dom', 'functions__throttle'], 
    function(provide, BEMDOM, throttle) {
        provide(BEMDOM.decl(this.name, {
            onSetMod : {
                'js' : {
                    'inited' : function() { 
                        this.bindTo('pointermove', throttle(this._heavyLoad, 300)); 
                    }
                }
            },
            _heavyLoad : function() { console.log('message'); }
    }));
});
```

В результате, функция будет выполняться не чаще чем раз в 300 миллисекунд.
